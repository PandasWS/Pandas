//===== Pandas Documentation ==============================
//= Pandas 脚本指令说明文档
//===== By: ==================================================
//= Pandas 开发团队
//===== Last Updated: ========================================
//= 2019年2月11日
//===== Description: =========================================
//= 此文档对 Pandas 添加的脚本指令进行功能说明以及介绍.
//============================================================

*setheaddir <朝向编号>{,<角色编号>};

调整角色纸娃娃脑袋的朝向

朝向编号:
	0 - 使纸娃娃的脑袋看向正前方
	1 - 使纸娃娃的脑袋向右看
	2 - 使纸娃娃的脑袋向左看

角色编号:
	可选参数, 若不携带此参数则控制当前脚本关联的角色
	若填写了指定角色编号, 那么就控制指定角色

返回值:
	该指令无论执行成功与否, 都不会有返回值

---------------------------------------

*setbodydir <朝向编号>{,<角色编号>};

调整角色纸娃娃身体的朝向

朝向编号:
	与 NPC 一致, 从 0 到 7 共 8 个方位可选择

角色编号:
	可选参数, 若不携带此参数则控制当前脚本关联的角色
	若填写了指定角色编号, 那么就控制指定角色

返回值:
	该指令无论执行成功与否, 都不会有返回值

---------------------------------------

*openbank {<角色编号>};

让指定的角色立刻打开银行界面 (只对拥有随身银行的客户端版本有效).

角色编号:
	可选参数, 若不携带此参数则控制当前脚本关联的角色
	若填写了指定角色编号, 那么就控制指定角色

返回值:
	若指定角色不在线, 则返回 0, 成功则返回 1

---------------------------------------

*instance_users <副本实例编号>;

获取指定的副本实例中已经进入副本地图的人数

副本实例编号:
	必填项, 这里填写的副本编号就是 instance_create 脚本指令返回的那个数值
	也可以用 instance_id 脚本指令来获得当前队伍关联的副本实例编号

返回值:
	成功直接返回副本中的人数, 副本不存在或副本中无人存在则返回 0

---------------------------------------

*cap <要判断的数值>,<最小值>,<最大值>;
*cap_value <要判断的数值>,<最小值>,<最大值>;

确保数值不低于给定的最小值, 不超过给定的最大值

要判断的数值:
	必填项, 数值类型的值

最小值:
	必填项, 数值类型的值

最大值:
	必填项, 数值类型的值

返回值:
	要判断的数值低于最小值则直接返回最小值, 超过最大值则直接返回最大值,
	如果要判断的数值在两者之间, 那么原样返回该数值

---------------------------------------

*mobremove <魔物的GID>;

根据 GID 移除一个魔物(只是移除, 不会让魔物死亡)

魔物的GID:
	必填项, 比如使用 monster 脚本指令后 $@mobid[] 数组的内容

返回值:
	该指令无论执行成功与否, 都不会有返回值
	
---------------------------------------

*mesclear;

清空玩家与当前 NPC 的对话框内容, 清空后可以用 mes 重新给对话框填充内容

不推荐使用:
	rAthena 已经推出了功能完全一致的指令 clear;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.
	此处的 mesclear 实际上是 clear 的别名, 以便兼容以前的部分脚本.

返回值:
	该指令无论执行成功与否, 都不会有返回值

---------------------------------------

*battleignore <开关标记>{,<角色编号>};

将指定的角色设置为魔物免战状态, 避免被魔物攻击
魔物会无视此玩家的存在, 因此不会攻击该玩家 (也可以叫无敌状态)

不推荐使用:
	rAthena 已经推出了类似的脚本指令解决方案.
	启用无敌状态等价于 rAthena 的官方指令用法: setpcblock PCBLOCK_IMMUNE, 1;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

开关标记:
	0 - 关闭免战 (角色会被魔物看见)
	1 - 打开免战 (角色不会被魔物看见, 也不会被攻击)

返回值:
	该指令无论执行成功与否, 都不会有返回值

---------------------------------------

*getinventorylist {<角色编号>};

在 rAthena 原来返回的数组基础上, Pandas 新增了以下返回数组:

- @inventorylist_idx[] 返回每个道具的背包序号.
- @inventorylist_uid$[] 返回每个道具的唯一编号 (字符串类型的数组, 末尾记得要带 $ 符号).

背包序号:
	背包序号每一次登录、每一次玩家在自己的背包中增删物品 (包括但不限: 
	存仓、存手推车、丢弃、购买和使用道具等操作) 都可能会导致背包序号有变化.
	所以请注意在一段连续、玩家不可能会停下来做其他动作的脚本中去使用“背包序号”.
	否则, 只要在 getinventorylist 之后, 还给玩家或脚本去进行道具的增删,
	那么 @inventorylist_idx[] 中的数据将立刻变得不再可靠.

---------------------------------------

*readparam(<参数代码>{,"<角色名称>"})
*readparam(<参数代码>{,<角色编号>})

在 rAthena 原来的参数代码基础上, Pandas 新增了以下几个参数:

bAllStr - 返回角色的总 STR (用总 STR 减去 bStr 可得到面板中 STR 在加号右侧的值)
bAllAgi - 返回角色的总 AGI (用总 AGI 减去 bAgi 可得到面板中 AGI 在加号右侧的值)
bAllVit - 返回角色的总 VIT (用总 VIT 减去 bVit 可得到面板中 VIT 在加号右侧的值)
bAllInt - 返回角色的总 INT (用总 INT 减去 bInt 可得到面板中 INT 在加号右侧的值)
bAllDex - 返回角色的总 DEX (用总 DEX 减去 bDex 可得到面板中 DEX 在加号右侧的值)
bAllLuk - 返回角色的总 LUK (用总 LUK 减去 bLuk 可得到面板中 LUK 在加号右侧的值)

使用方法:
	dispbottom "总STR为 : " + readparam(bAllStr) + " (" + readparam(bStr) + " + " + (readparam(bAllStr) - readparam(bStr)) + ")";

---------------------------------------

*gethotkey <快捷键位置编号>{,<要获取的数据类型>};
*get_hotkey <快捷键位置编号>{,<要获取的数据类型>};

获取指定快捷键位置的信息, 快捷键位置编号必须大于 0 小于 MAX_HOTKEYS.
MAX_HOTKEYS 是个常量, 在脚本中可以直接使用以下方法来确认它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

要获取的数据类型:
	可选参数, 若携带这个参数则函数的返回值会具备不同含义:
	0	- 获取快捷键的类型
		> 若返回 0 表示该位置的快捷键上放的是一个物品
		> 若返回 1 表示该位置的快捷键上放的是一个技能
	1	- 获取技能编号或物品编号
	2	- 获取登记在快捷键上的技能等级

	若不携带 <要获取的数据类型> 参数, 那么指定的快捷键的信息会被存放到以下角色变量:
	
	@hotkey_type	- 快捷键的类型 (为 0 表示物品, 为 1 表示技能)
	@hotkey_id		- 技能编号或物品编号
	@hotkey_lv		- 登记在快捷键上的技能等级

返回值:
	若携带 <要获取的数据类型> 参数时, 发生错误将返回 -1, 成功则返回查询的值;
	不携带 <要获取的数据类型> 参数时, 发生错误将返回 -1, 成功则将信息保存到变量并返回 1

---------------------------------------

*sethotkey <快捷键位置编号>,<快捷键的类型>,<物品编号/技能编号>,<技能等级>;
*set_hotkey <快捷键位置编号>,<快捷键的类型>,<物品编号/技能编号>,<技能等级>;

设置玩家快捷键工具栏上的内容, 快捷键位置编号必须大于 0 小于 MAX_HOTKEYS.
MAX_HOTKEYS 是个常量, 在脚本中可以直接使用以下方法来确认它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

快捷键的类型:
	0	- 这个快捷键想放置一个物品 (若使用该值, 则"技能等级"参数无意义, 请直接给"技能等级"参数传 0 即可)
	1	- 这个快捷键想放置一个技能

物品编号/技能编号:
	根据您 <快捷键的类型> 的取值不同而拥有不同含义, 程序会校验给定的物品编号或技能编号是否有效.

技能等级:
	只有当 <快捷键的类型> 的值为 1 时才有意义. 若是个物品的话, 这里随便传什么都会被默认为 0.

返回值:
	设置成功则返回 1, 设置失败则返回 0

---------------------------------------

*showvend "<NPC名称>",<是否显示>{,"<招牌名称>"};

使指定的 NPC 头上可以显示露天商店的招牌, 点击招牌可触发与 NPC 的对话.

NPC名称:
	你可以指定 NPC 的名称, 或者用 strnpcinfo(0) 获取当前 NPC 的名称.

是否显示:
	0 - 隐藏招牌 (当选择隐藏招牌时, <招牌名称> 参数可不传递)
	1 - 显示招牌

返回值:
	操作成功则返回 1, 操作失败则返回 0

---------------------------------------

*viewequip <目标的角色编号>{,<是否强制查看>};

查看指定在线角色的装备面板信息.

是否强制查看:
	0	- 若目标角色禁止其他玩家查看装备, 那么就不查看 (对 GM 无影响)
	1	- 无视目标角色设置, 强制进行查看

注意事项:
	在 Pandas v2.0.0 以前的版本中, 第一个参数提供的是账号编号而不是角色编号.
	现在统一改成角色编号, 请留意对相关的脚本进行升级调整.

返回值:
	操作成功则返回 1, 操作失败则返回 0

---------------------------------------

*countitemidx <背包序号>{,<角色编号>};
*countinventory <背包序号>{,<角色编号>};

获取指定背包序号的道具在背包中的数量. 

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回道具的数量, 操作失败则返回 0

---------------------------------------

*delitemidx <背包序号>{,<移除的数量>{,<角色编号>}};
*delinventory <背包序号>{,<移除的数量>{,<角色编号>}};

移除指定背包序号的道具, 支持指定移除数量以及目标角色编号. 
若被指定的道具已穿戴在目标角色身上, 那么该装备会被立刻脱下并移除.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

移除的数量:
	可选参数, 若不指定, 则表示你想删除指定道具的全部.

返回值:
	操作成功则返回 1, 操作失败则返回 0

---------------------------------------

*identifyidx <背包序号>{,<角色编号>};
*identifybyidx <背包序号>{,<角色编号>};

鉴定指定背包序号的道具.
只要背包序号合法, 哪怕道具已经被鉴定过, 该函数也会返回 1.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 操作失败则返回 0

---------------------------------------

*unequipidx <背包序号>{,<角色编号>};
*unequipinventory <背包序号>{,<角色编号>};

脱下指定背包序号的道具.
只要背包序号合法, 哪怕道具已被脱下, 该函数也会返回 1.
若指定的道具不是装备, 那么该函数将返回 0 (但不会报错, 也不会警告).

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 操作失败则返回 0

---------------------------------------

*equipidx <背包序号>{,<角色编号>};
*equipinventory <背包序号>{,<角色编号>};

穿戴指定背包序号的道具.
只要背包序号合法, 哪怕道具已被穿戴, 该函数也会返回 1.
若指定的道具不是装备, 那么该函数将返回 0 (但不会报错, 也不会警告).

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 操作失败则返回 0


---------------------------------------

*itemexists <物品编号/"物品名称">;
*existitem <物品编号/"物品名称">;

确认物品数据库中是否存在指定物品, 通常用于提高脚本的健壮性.

参数说明:
	第一参数是必填的多类型参数. 可以填写数值类型的道具编号, 或者字符串类型的道具名称.
	推荐使用道具编号, 相较而言结果会更加准确.

注意事项:
	第一个参数避免填写[字符串类型]的道具编号, 
	因为这里的参数只要是字符串类型的, 都会走物品名称判断逻辑.

返回值:
	若物品指定的道具编号不存在于数据库中则返回 0,
	若物品存在且[可堆叠]则返回[正数]物品编号, [不可堆叠]则返回[负数]物品编号

---------------------------------------

*renttime <EQI装备位置>,<增减的时间秒数>{,<角色编号>};
*setrenttime <EQI装备位置>,<增减的时间秒数>{,<角色编号>};
*resume <EQI装备位置>,<增减的时间秒数>{,<角色编号>};

增加/减少指定位置装备的租赁时间.
如果要减少租赁时间的话, 第二个参数请使用负数.

EQI装备位置:
	是指 EQI_* 开头的位置常量, 可参考 doc/script_commands.txt

增减的时间秒数:
	若需要减少时间的话, 请使用负数.

注意事项:
	input 指令会将所有小于 0 的用户输入数值变成 0.
	若您希望由玩家通过 input 指令来指定要减少的秒数, 那么需要加个负数符号.
	或者修改 conf/script_athena.conf 中 input_min_value 选项的值.

返回值:
	操作失败返回 0, 非 0 的正数表示成功增减后新的剩余时间秒数
	若指定位置没有穿戴装备, 或指定位置的装备并非租赁道具, 函数都会返回 0

---------------------------------------

*getequipidx <EQI装备位置>{,<角色编号>};

获取指定位置装备的背包序号. 注意该函数返回 0 不代表失败.

EQI装备位置:
	是指 EQI_* 开头的位置常量, 可参考 doc/script_commands.txt

返回值:
	-1 - 在指定的EQI装备位置找不到装备
	-2 - 填写的EQI装备位置无效
	-3 - 指定的角色编号无效, 或者目标玩家不在线
	其他大于等于 0 的数值则表示成功, 返回值就是所查位置装备的背包序号

---------------------------------------

*statuscalc;
*status_calc;

根据角色目前的装备、技能、状态以及其他各种加成, 重新执行计算玩家的能力.

不推荐使用:
	rAthena 已经推出了功能完全一致的指令 recalculatestat;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.
	此处的 statuscalc 和 status_calc 实际上是 recalculatestat 的别名, 以便兼容以前的部分脚本.

返回值:
	该指令无论执行成功与否, 都不会有返回值

---------------------------------------

*getequipexpiretick <EQI装备位置>{,<角色编号>};
*isrental <EQI装备位置>{,<角色编号>};

获取指定位置装备的租赁到期剩余秒数.

EQI装备位置:
	是指 EQI_* 开头的位置常量, 可参考 doc/script_commands.txt

返回值:
	-1 - 在指定的EQI装备位置找不到装备
	-2 - 填写的EQI装备位置无效
	-3 - 指定的角色编号无效, 或者目标玩家不在线
	 0 - 此装备不是租赁装备, 永久有效
	其他大于 0 的数值则代表租赁到期的剩余秒数

---------------------------------------

*getinventoryinfo <背包序号>,<要查看的信息类型>{,<角色编号>};

查询指定背包序号的道具的详细信息.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

要查看的信息类型:
	0 	- 物品编号
	1 	- 堆叠数量
	2 	- 装备的穿戴位置 (如果为 0 则表示还没穿戴在身上, 位置请参考 EQP_* 开头的常量)
	3 	- 精炼值
	4 	- 是否已鉴定 (1为已鉴定, 0为未鉴定)
	5 	- 属性 (说是属性, 其实最常用是用来判断物品是否损坏, 若损坏则返回1, 没坏则返回 0)
	6 	- 第一个卡槽的卡片编号
	7 	- 第二个卡槽的卡片编号
	8 	- 第三个卡槽的卡片编号
	9 	- 第四个卡槽的卡片编号
	10	- 过期时间 (Unix时间戳, 0 表示永不过期)
	11	- 装备的唯一编号(unique_id) - 注意: 返回字符串类型的变量

注意事项:
	用来存放装备唯一编号的返回值必须是字符串类型的变量 (即: 变量结尾带 $ 符号).
	如果用来存放返回值的变量是数值类型的话, 那么拿到的值不是装备的唯一编号, 且是不可预期的.

	.@uid$ = getinventoryinfo(背包序号, 11);	// 正确, 接收变量带 $ 符号结尾
	.@uid = getinventoryinfo(背包序号, 11);		// 错误

返回值:
	获取失败则返回 -1, 获取成功则返回你所查询的信息

---------------------------------------

*statuscheck <状态编号>{,<游戏单位编号>};
*sc_check <状态编号>{,<游戏单位编号>};

该指令用于判断状态是否存在, 并取得相关的状态参数.

不推荐使用:
	rAthena 已经推出了功能近似的指令 getstatus;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

状态编号:
	每一个增益或者减益状态都有一个编号, 脚本中一般用常量表示.
	比如负重超过 50% 的状态编号是: SC_WEIGHT50
	这部分的常量定义可以在: src/map/status.hpp 中的 sc_type 定义中找到.

游戏单位编号:
	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>

信息通过变量返回:
	当返回值为 1 的时候, 可以通过以下变量来读取状态的参数:

	@sc_val1		状态的第 1 个参数值 (如果是技能对应的状态的话, 往往这个参数都是技能等级)
	@sc_val2		状态的第 2 个参数值
	@sc_val3		状态的第 3 个参数值
	@sc_val4		状态的第 4 个参数值
	@sc_tickleft	状态的剩余时间 (单位为毫秒)

注意事项:
	若指定状态的剩余时间过长, @sc_tickleft 的返回值会变得不可靠.
	可保存的最大值为 2147483647 毫秒, 约等于 2147484 秒, 24.86 天.
	若状态的有效剩余时间大于这个值, 那么 @sc_tickleft 就容纳不下了.
	
	若您预判可能存在此问题, 那么还是推荐用 getstatus 来替代,
	因为 getstatus 获取信息的方式是通过指令返回值, 它可以保存更大的数值.

返回值:
	获取成功则返回 1, 角色没有该状态则返回 0, 其他错误返回 -1

---------------------------------------

*renttimeidx <背包序号>,<增减的时间秒数>{,<角色编号>};

增加/减少指定背包序号道具的租赁时间.
如果要减少租赁时间的话, 第二个参数请使用负数.

该指令与 renttime 近似, 只是 renttime 操作的是某个已穿戴的装备,
而 renttimeidx 指令可以通过背包序号来指定要调整的物品.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

增减的时间秒数:
	若需要减少时间的话, 请使用负数.

注意事项:
	input 指令会将所有小于 0 的用户输入数值变成 0.
	若您希望由玩家通过 input 指令来指定要减少的秒数, 那么需要加个负数符号.
	或者修改 conf/script_athena.conf 中 input_min_value 选项的值.

返回值:
	操作失败返回 0, 非 0 的正数表示成功增减后新的剩余时间秒数
	若指定位置没有穿戴装备, 或指定位置的装备并非租赁道具, 函数都会返回 0

---------------------------------------

*party_leave {<角色编号>};

使当前角色或指定角色退出队伍.

不推荐使用:
	rAthena 已经推出了功能近似的指令 party_delmember;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

角色编号:
	若不指定角色编号, 那么将会使执行该指令的玩家退出队伍.

返回值:
	若指定的角色不在线或不在队伍中则返回 0,
	若角色成功退出队伍则返回 1

---------------------------------------

*script4each <"{脚本}">,<脚本的执行范围>{,<动态参数>...};

对指定范围的玩家执行相同的一段脚本, 执行 <脚本> 的玩家将会成为其默认关联玩家.

全服玩家							- script4each "{<脚本>}",0;
指定地图上的全部玩家				- script4each "{<脚本>}",1,<"地图名称">;
以地图某个点为中心半径距离内的玩家	- script4each "{<脚本>}",2,<"地图名称">,<中心坐标x>,<中心坐标y>,<范围>;
指定玩家所在的队伍中的全部队伍成员	- script4each "{<脚本>}",3,<角色编号>;
指定玩家所在的公会中的全部公会成员	- script4each "{<脚本>}",4,<角色编号>;
指定区域内的全部玩家				- script4each "{<脚本>}",5,<"地图名称">,<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>;
指定队伍中的全部队伍成员			- script4each "{<脚本>}",6,<队伍编号>;
指定公会中的全部公会成员			- script4each "{<脚本>}",7,<公会编号>;

大括号转义: 
	从 Pandas v1.0.0 版本开始, 不再需要执行大括号转义.

可无视外层大括号:
	从 Pandas v1.0.1 版本开始, {<脚本>} 参数中最外层的大括号可以被忽略.

	例如, 以前必须加外层大括号, 否则会报错:

		script4each "{ getitem 501, 10; }", 0;

	现在, 可以直接忽略最外层大括号, 简写变成:

		script4each "getitem 501, 10;", 0;

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*searcharray <数组变量>,<要查找的字符串或数值>;

查询数组中第一次出现待查询内容的索引序号, 使用它来搜索数组内容很方便.

不推荐使用:
	rAthena 已经推出了功能近似的指令 inarray;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

返回值:
	若查不到结果则返回 -1, 否则返回大于等于 0 的索引序号

---------------------------------------

*getsameipinfo {<"IP地址">};

获得某个指定 IP 在线的玩家信息.
若不携带<"IP地址">参数, 则默认查询当前脚本关联角色的 IP 地址.

IP地址:
	可选参数, 若需要指定的话请填写标准的 4 段式 IP 地址,
	例如: getsameipinfo "114.114.114.114"

信息通过变量返回:

	@sameip_aid[]		该 IP 在线的玩家账号编号数组 - 数值型数组
	@sameip_cid[]		该 IP 在线的玩家角色编号数组 - 数值型数组
	@sameip_name$[]		该 IP 在线的玩家角色名称数组 - 字符型数组

返回值及 @sameip_amount 变量都会赋予目前使用指定IP登录的玩家个数.

提示信息:
	官方自带的 getcharip 脚本指令可以获得某个玩家的 IP 地址,
	配合这个指令, 就能知道对方相同 IP 下有几个角色在线.

返回值:
	出错返回 -1, 其他含 0 正整数表示查到的此 IP 的在线玩家数

---------------------------------------

*logout <登出理由>{,"<角色名称>"|<账号编号>|<角色编号>};

使指定的角色立刻登出游戏(踢下线), 此处的"登出理由"只能做参考,
不同的理由编号会让客户端给玩家显示不同的 msgstringtable 提示文本:

登出理由:
	0 = BAN_UNFAIR
	1 = 服务器已关闭 -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = 连接超时 / 网络延迟不稳定 -> MsgStringTable[241]
	4 = 服务器已经满员 -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = 被 GM 踢下线 -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	111 = 与服务器断开连接 -> MsgStringTable[3]

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*warppartyrevive "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};
*warpparty2 "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};

该指令的用法与 warpparty 完全一样, 都是将指定队伍全员传送到指定目的地.

区别在于: 
	warpparty 对已经死亡的队友则无效 (死亡的队友会被留在原地),
	warppartyrevive 对已经死亡的队友有效 (队友会被立刻复活, 并一起被传送走).

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*getareagid <返回数组>,<搜索范围>{,<动态参数>...};

获取指定范围内特定类型单位的全部 GID, 并返回到指定的数组中.

返回数组:
	必填项, 需要指定一个用于返回GID的数值型数组
	若给定的是角色相关变量 (比如角色变量级的数组), 那么脚本必须关联到某个玩家
	若给定的是系统相关变量 (比如地图服务器的数组), 那么脚本无需关联到某个玩家

搜索范围:
	指定地图上的全部玩家				- getareagid <返回数组>,0,<想搜索的单位类型>,<"地图名称">;
	以地图某个点为中心半径距离内的玩家	- getareagid <返回数组>,1,<想搜索的单位类型>,<"地图名称">,<中心坐标x>,<中心坐标y>,<范围>;
	指定区域内的全部玩家				- getareagid <返回数组>,2,<想搜索的单位类型>,<"地图名称">,<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>;

想搜索的单位类型:
	BL_PC		- 玩家角色单位
	BL_MOB		- 魔物单位
	BL_PET		- 宠物单位
	BL_HOM		- 人工生命体单位
	BL_MER		- 佣兵单位
	BL_ITEM		- 物品单位
	BL_SKILL	- 技能单位
	BL_NPC		- NPC单位
	BL_CHAT		- 聊天室单位
	BL_ELEM		- 元素精灵单位
	BL_ALL		- 全部单位类型

地图名称:
	指定的地图名称, 比如 "prontera" 表示普隆德拉
	地图名称可以设置为 "this", 表示获取当前脚本关联玩家所在的地图

注意事项:
	该指令被重新设计过, 参数相比 rAthenaCN 老版本有所不同, 使用时需要注意.

返回值:
	操作失败返回 -1, 其他含 0 正整数表示搜索到的 GID 数量

---------------------------------------

*getiteminfo(<物品编号>,<查询的信息类型>{,<用于返回附加数据的数组>})

在 rAthena 原来的参数代码基础上, Pandas 新增了一些查询信息类型.

注意事项:
	从 v1.0.1 版本的 Pandas 开始, -5 类型的返回值不再直接返回支持捕捉的魔物编号

查询的信息类型:
	-1	-	是否可精炼
	-2	-	交易限制掩码
	-3	-	避免物品被玩家主动使用而消耗
	-4	-	避免物品被作为发动技能的必要道具而消耗		
	-5	-	是否为宠物捕捉道具
	-6	-	是否在其使用脚本中调用了 callfunc 指令

返回值:
	-1	-	返回 1 表示可以精炼, 0 表示不能精炼
	-2	-	返回该物品在 item_trade 数据库中第二列定义的值
	-3	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-4	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-5	-	返回 1 表示这是一个宠物捕捉道具 (<用于返回附加数据的数组> 将返回支持捕捉的魔物编号), 0 表示不是
	-6	-	返回 0 表示没有调用 callfunc 函数, 返回 1 表示调用了 callfunc 函数
	
	其中 -5 和 -6 若返回 -2 则表示未编译此功能
	以上全部信息类型, 若返回 -1 表示这个物品编号是不存在或无效的.

用于返回附加数据的数组:
	目前仅 -5 类型会使用到, 如果查询 -5 类型的时候指定 <用于返回附加数据的数组>
	那么该道具支持捕捉的魔物编号将会填充到这个数组中 (注意: 只能使用数值型数组).

示例代码:
	prontera,150,150,5	script	查询抓宠道具	123,{
		mes "[查询抓宠道具]";
		mes "请输入要查询的道具编号.";
		next;
		
		input .@nameid;
		cleararray .@taming_mobid, 0, getarraysize(.@taming_mobid);
		.@result = getiteminfo(.@nameid, -5, .@taming_mobid);
		
		if (.@result == -1) {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 道具编号不存在或无效";
		}
		else if (.@result == -2) {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 此功能未编译到代码中";
		}
		else if (.@result == 1) {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 这是抓宠道具, 能抓:";
			mes "==========";
			for (.@i = 0; .@i < getarraysize(.@taming_mobid); .@i++) {
				mes "> 魔物编号: " + .@taming_mobid[.@i];
			}
		}
		else {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 这应该不是抓宠道具";
		}
		close;
	}

---------------------------------------

*processhalt {<是否设置中断>};

该指令只能在事件处理脚本中使用.
设置中断可以打断本次事件脚本结束后的源代码后续逻辑.

每个事件的源代码后续逻辑各有不同, 且只能用于部分事件, 详情请参考事件说明文档.

是否设置中断:
	可选参数, 填写 0 表示取消中断, 填写 1 表示设置中断.
	若不携带该参数则默认为: 1 - 设置中断

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*settrigger <事件的常量名称>,<触发行为>;

使用该指令可以设置某个事件或过滤器的触发行为

事件的常量名称:
	每个事件或过滤器在代码中都有自己唯一的常量名称, 这些常量名称与事件名的关联如下:
	
	NPCE_LOGIN				-	OnPCLoginEvent
	NPCE_LOGOUT				-	OnPCLogoutEvent
	NPCE_LOADMAP			-	OnPCLoadMapEvent
	NPCE_BASELVUP			-	OnPCBaseLvUpEvent
	NPCE_JOBLVUP			-	OnPCJobLvUpEvent
	NPCE_DIE				-	OnPCDieEvent
	NPCE_KILLPC				-	OnPCKillEvent
	NPCE_KILLNPC			-	OnNPCKillEvent
	NPCE_STATCALC			-	OnPCStatCalcEvent
	
	NPCF_IDENTIFY			-	OnPCIdentifyFilter
	NPCF_ENTERCHAT			-	OnPCInChatroomFilter
	NPCF_INSERT_CARD		-	OnPCInsertCardFilter
	NPCF_USE_ITEM			-	OnPCUseItemFilter
	NPCF_USE_SKILL			-	OnPCUseSkillFilter
	NPCF_ROULETTE_OPEN		-	OnPCOpenRouletteFilter
	NPCF_VIEW_EQUIP			-	OnPCViewEquipFilter
	
	NPCE_KILLMVP			-	OnPCKillMvpEvent
	NPCE_IDENTIFY			-	OnPCIdentifyEvent
	NPCE_INSERT_CARD		-	OnPCInsertCardEvent
	NPCE_USE_ITEM			-	OnPCUseItemEvent
	NPCE_USE_SKILL			-	OnPCUseSkillEvent
	NPCE_PROGRESS_ABORT		-	OnPCProgressAbortEvent

触发行为:
	EVENT_TRIGGER_DISABLED	- 禁止触发此事件或过滤器
	EVENT_TRIGGER_ONCE		- 允许下次触发此事件或过滤器
	EVENT_TRIGGER_EVER		- 允许永久触发此事件或过滤器

---------------------------------------

*messagecolor "<消息文本>"{,"<文本颜色代码>",<发送目标>,<游戏单位编号>};

使用该指令可以发送指定颜色的消息文本到聊天窗口中.
除了发送者以外的其他角色可以见到消息发送者角色头上顶着文本气泡.

消息文本:
	消息的正文, 字符串类型, 没什么特别的.

文本颜色代码:
	可选参数, 默认发送的字体颜色为白色.
	该参数使用 RRGGBB 格式的字符串来传递色值, 例如红色是: "ff0000"

发送目标:
	- bc_all  : 全服务器的在线玩家都可见.
	- bc_map  : 与发送者处于相同地图的玩家都可见.
	- bc_area : 发送者视野范围内的玩家可见 (默认值).
	- bc_self : 仅发送者自己可见.

游戏单位编号:
	默认情况下的发送者就是使用该指令脚本所关联的玩家,
	必要的情况下您可以使用这个参数来指定其他的发送者, 以便达到想要的效果.

	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>

---------------------------------------

*copynpc "<复制出来的新NPC所在地图名称>,<X坐标>,<Y坐标>,<朝向编号>","duplicate(<来源NPC名称>)","<复制出来的新NPC名称>","<图档外观编号>";
*copynpc "<复制出来的新NPC所在地图名称>",<X坐标>,<Y坐标>,<朝向编号>,"<来源NPC名称>","<复制出来的新NPC名称>",<图档外观编号>;

使用该指令可以复制指定的 NPC 到一个新的位置.
该指令从 v1.0.1 版本开始, 拥有两个不同的参数版本可供随意选择, 程序将根据参数的个数进行自动识别.

============
四参数版本
============

	需要携带 4 个字符串参数, 参数的内容需要脚本作者进行准确的拼接操作.

	参数看起来很多, 实际上是由 4 个字符串参数组成的,
	这 4 个字符串与使用 duplicate 进行静态复制时候的四个用 %TAB% 分隔的内容是一样的.

	参数说明:
		第一个参数: "<复制出来的新NPC所在地图名称>,<X坐标>,<Y坐标>,<朝向编号>"
		第二个参数: "duplicate(<来源NPC名称>)"
		第三个参数: "<复制出来的新NPC名称>"
		第四个参数: "<图档外观编号>"

	举例说明:
		假设有以下 NPC 我们想把它复制一个新的出来:

			prontera,146,99,2    script    PVP管理员::PVPCOPYTEST    123,{
				mes "[PVP管理员]";
				mes "场地正在修理, 请稍后再来...";
				close;
			}

		通常的做法是在脚本中, 使用 duplicate 指令进行静态复制, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理员#1	123
		
		现在你可以使用 copynpc 脚本指令, 将上面这一行静态复制代码按 %TAB% 分割为4个字段,
		然后以字符串形式传递给 copynpc 脚本指令, 如:
		
			copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理员#2","123";
			
			这里第二个参数支持简化 duplicate 关键字, 可以用以下语句实现同样的效果:
			
			copynpc "prontera,156,99,2","PVPCOPYTEST","PVP管理员#2","123";
		
		同时此函数支持返回复制出来的新 NPC 的 GID, 方便你使用 unit 系列指令对其进行操作, 如:
		
			.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理员#3","123");
			unittalk .@gid, "我是新克隆出来的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要复制一个副本中的 NPC, 那么需要在用到地图名称的地方使用 instance_mapname 进行转换,
		原始 NPC 的名称也需要用 instance_npcname 进行转换, 如:
		
			.@w1 = instance_mapname("1@tower") + ",156,99,2";
			.@w2 = "duplicate(" + instance_npcname("PVPCOPYTEST") + ")";
			.@w3 = "PVP管理员#4";
			.@w4 = "123";
			
			copynpc .@w1, .@w2, .@w3, .@w4;

============
七参数版本
============

	需要携带 7 个参数, 参数的内容可以直接用对应类型的变量直接传递, 更方便理解.
	
	参数说明:
		第一个参数: 字符串类型	-	"<复制出来的新NPC所在地图名称>"
		第二个参数: 数值类型	-	<X坐标>
		第三个参数: 数值类型	-	<Y坐标>
		第四个参数: 数值类型	-	<朝向编号>
		第五个参数: 字符串类型	-	"<来源NPC名称>"
		第六个参数: 字符串类型	-	"<复制出来的新NPC名称>"
		第七个参数: 数值类型	-	<图档外观编号>

	举例说明:
		假设有以下 NPC 我们想把它复制一个新的出来:

			prontera,146,99,2    script    PVP管理员::PVPCOPYTEST    123,{
				mes "[PVP管理员]";
				mes "场地正在修理, 请稍后再来...";
				close;
			}

		通常的做法是在脚本中, 使用 duplicate 指令进行静态复制, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理员#1	123
		
		现在你可以使用 copynpc 脚本指令直接复制:
		
			copynpc "prontera",156,99,2,"duplicate(PVPCOPYTEST)","PVP管理员#2",123;
			
			这里第二个参数支持简化 duplicate 关键字, 可以用以下语句实现同样的效果:
			
			copynpc "prontera",156,99,2,"PVPCOPYTEST","PVP管理员#2",123;
		
		同时此函数支持返回复制出来的新 NPC 的 GID, 方便你使用 unit 系列指令对其进行操作, 如:
		
			.@gid = copynpc("prontera",156,99,2,"PVPCOPYTEST","PVP管理员#3",123);
			unittalk .@gid, "我是新克隆出来的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要复制一个副本中的 NPC, 那么需要在用到地图名称的地方使用 instance_mapname 进行转换,
		原始 NPC 的名称也需要用 instance_npcname 进行转换, 如:
		
			copynpc instance_mapname("1@tower"),156,99,2,instance_npcname("PVPCOPYTEST"),"PVP管理员#4",123;

============
公用说明
============

	返回值:
		复制成功则返回复制出来的新 NPC 的 GID, 失败则返回 0

	注意事项:
		复制商店类型的 NPC 时, 来源 NPC 和目标 NPC 它们之间的道具列表是相互独立的.
		
		若指定了一个无效的外观编号, 那么地图服务器虽然会报 status_set_viewdata 错误,
		但是实际上 NPC 还是会复制成功 (只不过你看不见它).
		此时可以用 setunitdata 调整这个 NPC 的 UNPC_DISPLAY 参数, 重新给他一个外观.

---------------------------------------

*gettimefmt <"时间格式化标准">{,<要转换的秒数>{,<是否格式化成 UTC 时间>}};

时间格式化标准:
	与 gettimestr 函数的第一个参数完全一样.
	可以参考: https://www.runoob.com/cprogramming/c-function-strftime.html

要转换的秒数:
	可选参数, 如果你指定了一个秒数, 那么指令将不会转换当前系统时间, 而是转换你给定的时间

是否格式化成 UTC 时间:
	可选参数, 默认值为 0, 填写 1 表示是. 如果格式化成 UTC 时间, 则不会包含时区.
	
	dispbottom gettimefmt("%H:%M:%S", 10);		// 在北京的话, 返回: 08:00:10 (北京时区是 UTC + 08:00:00)
	dispbottom gettimefmt("%H:%M:%S", 10, 1);	// 返回: 00:00:10

返回值:
	成功则返回被格式化的时间, 失败则返回空字符串

---------------------------------------

*mpet <魔物编号>{,<魔物编号>...}
*multicatchpet <魔物编号>{,<魔物编号>...}

与 pet / catchpet 指令类似, 但可以设定多个支持捕捉的魔物编号

魔物编号:
	必须是存在于 db/{pre-}re/pet_db.yml 中定义的魔物编号
	没有定义在 pet_db.yml 的魔物, 我们无法知道它的食物和饥饿率等数据

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

