//===== 熊猫模拟器 (PandasWS/Pandas) 文档 ====================
//= 脚本指令 (Script Command) 说明文档
//===== 维护人员 =============================================
//= 熊猫模拟器开发团队
//===== 最后更新 =============================================
//= 20220514 (不一定准)
//===== 文档描述 =============================================
//= 此文档对熊猫模拟器添加的脚本指令进行说明.
//============================================================

-%TAB%pointshop%TAB%<NPC名称>%TAB%<外观编号>,<货币变量|货币昵称>{:<折扣>},<出售的道具编号>:<售价>{,<出售的道具编号>:<售价>...}
<地图名称>,<X坐标>,<Y坐标>,<面部朝向>%TAB%pointshop%TAB%<NPC名称>%TAB%<外观编号>,<货币变量|货币昵称>{:<折扣>},<出售的道具编号>:<售价>{,<出售的道具编号>:<售价>...}

在 rAthena 设计的 pointshop 类型的商店允许我们使用数值变量的值作为货币.
这让我们将类似: 战场积分、泡点积分 这样的自定义积分值开放给玩家通过 pointshop 进行道具兑换来说体验很棒.

在这个设计中唯一美中不足的地方就是每次玩家访问 pointshop 类型的商店,
程序都会提示玩家当前这个商店使用的变量名称, 比如你写:

prontera,150,150,3	pointshop	testshop	123,BattleScoreVar,501:10

他会在每次玩家访问的时候都告诉玩家这个商店使用: BattleScoreVar 进行结算...
母语不是英文的亚洲玩家看到 BattleScoreVar 会感觉很奇怪, 因为这并不是他熟悉的表述方式,
正因为如此, 支持为货币变量起一个别名就变得非常必要.

做法很简单, 就是在变量名称末尾使用 | 后面写上这个货币变量的昵称, 例如:

prontera,150,150,3	pointshop	testshop	123,BattleScoreVar|战场积分,501:10

这样玩家访问这个商店的时候, 程序就会提示玩家这个商店使用: 战场积分 进行结算.
如此一来体验就会改善很多... 

这个功能熊猫模拟器很早很早就在代码中支持了, 最初可以追溯到 rAthenaCN 项目...
只是一直忘记补充相关的文档, 导致很多朋友在使用上不太方便.

--------------------------------------------------------------

*setheaddir <朝向编号>{,<角色编号>};

调整角色纸娃娃脑袋的朝向

朝向编号:
	0 = 相对于身体朝向的正前方, 头部看向正前方
	1 = 相对于身体朝向的正前方, 头部看向右看
	2 = 相对于身体朝向的正前方, 头部看向左看

角色编号:
	可选参数, 若不携带此参数则控制当前脚本关联的角色
	若填写了指定角色编号, 那么就控制指定角色

返回值:
	该指令无论执行成功与否, 都不会有返回值

--------------------------------------------------------------

*setbodydir <朝向编号>{,<角色编号>};

调整角色纸娃娃身体的朝向

朝向编号:
    1 = 西北      0 = 正北      7 = 东北
              ↖     |     ↗
    2 = 正西  <-     +     ->   6 = 正东
              ↙     |     ↘
    3 = 西南      4 = 正南      5 = 东南

角色编号:
	可选参数, 若不携带此参数则控制当前脚本关联的角色
	若填写了指定角色编号, 那么就控制指定角色

返回值:
	该指令无论执行成功与否, 都不会有返回值

--------------------------------------------------------------

*openbank {<角色编号>};

让指定的角色立刻打开银行界面 (只对拥有随身银行的客户端版本有效).

角色编号:
	可选参数, 若不携带此参数则控制当前脚本关联的角色
	若填写了指定角色编号, 那么就控制指定角色

返回值:
	若打开银行失败则返回 0, 成功则返回 1

--------------------------------------------------------------

*instance_users <副本实例编号>;

获取指定的副本实例中已经进入副本地图的人数

副本实例编号:
	必填项, 这里填写的副本编号就是 instance_create 脚本指令返回的那个数值

举例说明:
	可以用 instance_id 脚本指令来获得当前队伍关联的副本实例编号
	
	.@party_instance_id = instance_id(IM_PARTY);
	if (.@party_instance_id == 0) {
		dispbottom "你的队伍当前并没有创建副本.";
	}
	dispbottom "副本地图中当前人数: " + instance_users(.@party_instance_id) + " 人";

返回值:
	成功直接返回副本中的人数, 副本不存在或副本中无人存在则返回 0

--------------------------------------------------------------

*cap <要判断的数值>,<最小值>,<最大值>;

确保数值不低于给定的最小值, 不超过给定的最大值

要判断的数值:
	必填项, 数值类型的值

最小值:
	必填项, 数值类型的值

最大值:
	必填项, 数值类型的值

不推荐使用:
	rAthena 已经推出了功能完全一致的指令 cap_value;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.
	此处的 cap 实际上是 cap_value 的别名, 以便兼容以前的部分脚本.

返回值:
	要判断的数值低于最小值则直接返回最小值, 超过最大值则直接返回最大值,
	如果要判断的数值在两者之间, 那么原样返回该数值

--------------------------------------------------------------

*mobremove <魔物的GID>;

根据 GID 移除一个魔物(只是移除, 不会让魔物死亡)

魔物的GID:
	必填项, 比如使用 monster 脚本指令后 $@mobid[] 数组的内容

返回值:
	该指令无论执行成功与否, 都不会有返回值
	
--------------------------------------------------------------

*mesclear;

清空玩家与当前 NPC 的对话框内容, 清空后可以用 mes 重新给对话框填充内容

不推荐使用:
	rAthena 已经推出了功能完全一致的指令 clear;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.
	此处的 mesclear 实际上是 clear 的别名, 以便兼容以前的部分脚本.

返回值:
	该指令无论执行成功与否, 都不会有返回值

--------------------------------------------------------------

*battleignore <开关标记>{,<角色编号>};

将指定的角色设置为魔物免战状态, 避免被魔物攻击
魔物会无视此玩家的存在, 因此不会攻击该玩家 (也可以叫无敌状态)

不推荐使用:
	rAthena 已经推出了类似的脚本指令解决方案.
	启用无敌状态等价于 rAthena 的官方指令用法: setpcblock PCBLOCK_IMMUNE, 1;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

开关标记:
	0 - 关闭免战 (角色会被魔物看见)
	1 - 打开免战 (角色不会被魔物看见, 也不会被攻击)

返回值:
	该指令无论执行成功与否, 都不会有返回值

--------------------------------------------------------------

*getinventorylist {<角色编号>{,<想查询的数据类型>}};

用于查询玩家背包中的物品列表以及物品的全部详情信息, 该指令在 rAthena 的基础上得到了改进.

想查询的数据类型:
	有的用户会把玩家的背包扩充到一个比较大的值, 这时候如果还有一个脚本频繁调用 getinventorylist 的话,
	会导致程序默认填充几乎所有物品信息回来, 而往往很多信息我们用不到, 这就会出现多余的性能开销.

	你可以通过该掩码参数来控制指令内部给你填充指定的一个或多个数组, 降低程序填充数据的工作量来降低卡顿.

	INV_ID              = 填充 @inventorylist_id[]                  - 道具编号
	INV_IDX             = 填充 @inventorylist_idx[]                 - 道具的背包序号
	INV_AMOUNT          = 填充 @inventorylist_amount[]              - 道具的数量
	INV_EQUIP           = 填充 @inventorylist_equip[]               - 道具当前的装备位置
	INV_REFINE          = 填充 @inventorylist_refine[]              - 道具的精炼值
	INV_IDENTIFY        = 填充 @inventorylist_identify[]            - 道具是否已鉴定 (0: 未鉴定; 1: 已鉴定)
	INV_ATTRIBUTE       = 填充 @inventorylist_attribute[]           - 道具的属性

	INV_CARD            = 填充物品的插卡信息数组:
	                      @inventorylist_card1[]                   - 道具一号卡槽的卡片编号
	                      @inventorylist_card2[]                   - 道具二号卡槽的卡片编号
	                      @inventorylist_card3[]                   - 道具三号卡槽的卡片编号
	                      @inventorylist_card4[]                   - 道具四号卡槽的卡片编号

	INV_EXPIRE          = 填充 @inventorylist_expire[]              - 道具的过期时间戳 (0: 永不过期; 其他非零正整数表示 Unix 时间戳)
	INV_BOUND           = 填充 @inventorylist_bound[]               - 道具的绑定状态
	INV_ENCHANTGRADE    = 填充 @inventorylist_enchantgrade[]        - 道具的附魔评级

	INV_OPTION          = 填充物品随机属性(Random Option)的信息数组:
	                      @inventorylist_option_id1[]
	                      @inventorylist_option_value1[]
	                      @inventorylist_option_parameter1[]
	                      @inventorylist_option_id2[]
	                      @inventorylist_option_value2[]
	                      @inventorylist_option_parameter2[]
	                      @inventorylist_option_id3[]
	                      @inventorylist_option_value3[]
	                      @inventorylist_option_parameter3[]
	                      @inventorylist_option_id4[]
	                      @inventorylist_option_value4[]
	                      @inventorylist_option_parameter4[]
	                      @inventorylist_option_id5[]
	                      @inventorylist_option_value5[]
	                      @inventorylist_option_parameter5[]

	INV_TRADABLE        = 填充 @inventorylist_tradable[]           - 道具是否可交易
	INV_FAVORITE        = 填充 @inventorylist_favorite[]           - 道具是否被标记为最喜欢的道具 (0: 未标记; 1: 已标记)
	INV_UID             = 填充 @inventorylist_uid$[]               - 道具的唯一编号 (字符串类型的数组, 末尾记得要带 $ 符号)
	INV_EQUIPSWITCH     = 填充 @inventorylist_equipswitch[]        - 道具作为第二套快速切换装备时的穿戴位置
	INV_ALL             = 填充以上全部数组(默认值)

举例说明:
	想查询背包中所有道具的信息, 但只希望获取背包序号和数量:
	getinventorylist(getcharid(0), INV_IDX | INV_AMOUNT);

注意事项:
	若你指定了需要查询的数据类型, 那么未被查询的数据数组将不会被填充.

背包序号:
	背包序号每一次登录、每一次玩家在自己的背包中增删物品 (包括但不限: 
	存仓、存手推车、丢弃、购买和使用道具等操作) 都可能会导致背包序号有变化.
	所以请注意在一段连续、玩家不可能会停下来做其他动作的脚本中去使用“背包序号”.
	否则, 只要在 getinventorylist 之后, 还给玩家或脚本去进行道具的增删,
	那么 @inventorylist_idx[] 中的数据将立刻变得不再可靠.

--------------------------------------------------------------

*getcartlist {<角色编号>{,<想查询的数据>}};

与 getinventorylist 类似, 但是查询的是玩家的手推车中的物品信息.
它的返回数组与 getinventorylist 完全一致, 只是部分数组的意义会发生变化:

- @inventorylist_favorite[]     - 该数组无意义并且值固定为 0,
                                  因为手推车中的道具不能被标记为最喜欢的道具.
- @inventorylist_equipswitch[]  - 该数组无意义并且值固定为 0,
                                  因为手推车中的道具不能被作为第二套快速切换装备.
- @inventorylist_idx[]          - 道具的手推车序号

特别注意:
	这里 @inventorylist_idx[] 读取到的序号不再是道具的背包序号,
	应该使用 getcartinfo 而不是 getinventoryinfo 来获取物品的详细信息.
	
	玩家必须拥有手推车才能调用该指令, 否则会抛出错误.
	
	若想规避终端提示无手推车错误, 
	可以在调用该指令之前使用 checkcart() 来确保玩家有手推车.

--------------------------------------------------------------

*getguildstoragelist {<角色编号>{,<想查询的数据>}};

与 getinventorylist 类似, 但是查询的是公会仓库中的物品信息.
它的返回数组与 getinventorylist 完全一致, 只是部分数组的意义会发生变化:

- @inventorylist_favorite[]     - 该数组无意义并且值固定为 0,
                                  因为公会仓库中的道具不能被标记为最喜欢的道具.
- @inventorylist_equipswitch[]  - 该数组无意义并且值固定为 0,
                                  因为公会仓库中的道具不能被作为第二套快速切换装备.
- @inventorylist_idx[]          - 道具的公会仓库序号

特别注意:
	这里 @inventorylist_idx[] 读取到的序号不再是道具的背包序号,
	应该使用 getguildstorageinfo 而不是 getinventoryinfo 来获取物品的详细信息.
	
	玩家必须加入拥有公会仓库的公会才能调用该指令, 否则会抛出错误.
	
	若想规避终端提示未加入公会以及没有公会仓库的错误,
	可以在调用该指令之前使用 getgdskilllv(getcharid(2), "GD_GUILD_STORAGE") > 0
	来确保玩家已加入有公会仓库的公会.

--------------------------------------------------------------

*getstoragelist {<角色编号>{,<想查询的数据>{,<仓库编号>}}};

与 getinventorylist 类似, 但是查询的是个人仓库/扩充仓库中的物品信息.
它的返回数组与 getinventorylist 完全一致, 只是部分数组的意义会发生变化:

- @inventorylist_favorite[]     - 该数组无意义并且值固定为 0,
                                  因为个人仓库/扩充仓库中的道具不能被标记为最喜欢的道具.
- @inventorylist_equipswitch[]  - 该数组无意义并且值固定为 0,
                                  因为个人仓库/扩充仓库中的道具不能被作为第二套快速切换装备.
- @inventorylist_idx[]          - 道具的个人仓库/扩充仓库序号

特别注意:
	这里 @inventorylist_idx[] 读取到的序号不再是道具的背包序号,
	应该使用 getstorageinfo 而不是 getinventoryinfo 来获取物品的详细信息.

仓库编号:
	该指令支持获取扩充仓库的内容, 因此你需要在查询时指定仓库编号.

	0 - 个人仓库 (每个玩家都会有的默认仓库)
	X - 扩充仓库 (其他非 0 的定义在 conf/inter_athena.yml 中的有效仓库编号)

注意事项:
	该指令的参数顺序和 getinventorylist、getcartlist、
	getguildstoragelist 有所差异, 使用的时候一定要注意, 不要被坑了.

--------------------------------------------------------------

*readparam(<参数代码>{,"<角色名称>"})
*readparam(<参数代码>{,<角色编号>})

在 rAthena 原来的参数代码基础上, 熊猫模拟器新增了以下几个参数:

bAllStr - 返回角色的总 STR (用总 STR 减去 bStr 可得到面板中 STR 在加号右侧的值)
bAllAgi - 返回角色的总 AGI (用总 AGI 减去 bAgi 可得到面板中 AGI 在加号右侧的值)
bAllVit - 返回角色的总 VIT (用总 VIT 减去 bVit 可得到面板中 VIT 在加号右侧的值)
bAllInt - 返回角色的总 INT (用总 INT 减去 bInt 可得到面板中 INT 在加号右侧的值)
bAllDex - 返回角色的总 DEX (用总 DEX 减去 bDex 可得到面板中 DEX 在加号右侧的值)
bAllLuk - 返回角色的总 LUK (用总 LUK 减去 bLuk 可得到面板中 LUK 在加号右侧的值)

CartWeight - 手推车中的物品总重量 (脱下手推车时数值为 0)
MaxCartWeight - 手推车的最大负重量 (脱下手推车时数值为 0)

使用方法:
	dispbottom "总STR为 : " + readparam(bAllStr) + " (" + readparam(bStr) + " + " + (readparam(bAllStr) - readparam(bStr)) + ")";
	dispbottom "手推车当前负重情况: " + CartWeight + "/" + MaxCartWeight;

提示信息:
	被 readparam 调用的有效 <参数代码> 可以直接当做常量使用

--------------------------------------------------------------

*gethotkey <快捷键位置编号>{,<要获取的数据类型>};

获取指定快捷键位置的信息, 快捷键位置编号必须大于 0 小于 MAX_HOTKEYS.
MAX_HOTKEYS 是个常量, 在脚本中可以直接使用以下方法来确认它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

要获取的数据类型:
	可选参数, 若携带这个参数则函数的返回值会具备不同含义:
	0	- 获取快捷键的类型
		> 若返回 0 表示该位置的快捷键上放的是一个物品
		> 若返回 1 表示该位置的快捷键上放的是一个技能
	1	- 获取技能编号或物品编号
	2	- 获取登记在快捷键上的技能等级

	若不携带 <要获取的数据类型> 参数, 那么指定的快捷键的信息会被存放到以下角色变量:
	
	@hotkey_type	- 快捷键的类型 (为 0 表示物品, 为 1 表示技能)
	@hotkey_id		- 技能编号或物品编号
	@hotkey_lv		- 登记在快捷键上的技能等级

返回值:
	若携带 <要获取的数据类型> 参数时, 发生错误将返回 -1, 成功则返回查询的值;
	不携带 <要获取的数据类型> 参数时, 发生错误将返回 -1, 成功则将信息保存到变量并返回 1

--------------------------------------------------------------

*sethotkey <快捷键位置编号>,<快捷键的类型>,<物品编号/技能编号>,<技能等级>;

设置玩家快捷键工具栏上的内容, 快捷键位置编号必须大于 0 小于 MAX_HOTKEYS.
MAX_HOTKEYS 是个常量, 在脚本中可以直接使用以下方法来确认它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

快捷键的类型:
	0	- 这个快捷键想放置一个物品 (若使用该值, 则"技能等级"参数无意义, 请直接给"技能等级"参数传 0 即可)
	1	- 这个快捷键想放置一个技能

物品编号/技能编号:
	根据您 <快捷键的类型> 的取值不同而拥有不同含义, 程序会校验给定的物品编号或技能编号是否有效.

技能等级:
	只有当 <快捷键的类型> 的值为 1 时才有意义. 若是个物品的话, 这里随便传什么都会被默认为 0.

返回值:
	设置成功则返回 1, 设置失败则返回 0

--------------------------------------------------------------

*showvend "<NPC名称>",<是否显示>{,"<招牌名称>"};

使指定的 NPC 头上可以显示露天商店的招牌, 点击招牌可触发与 NPC 的对话.

NPC名称:
	你可以指定 NPC 的名称, 或者用 strnpcinfo(0) 获取当前 NPC 的名称.

是否显示:
	0 - 隐藏招牌 (当选择隐藏招牌时, <招牌名称> 参数可不传递)
	1 - 显示招牌

返回值:
	操作成功则返回 1, 操作失败则返回 0

--------------------------------------------------------------

*viewequip <目标的角色编号|目标的账号编号>{,<是否强制查看>};

查看指定在线角色的装备面板信息.

是否强制查看:
	0	- 若目标角色禁止其他玩家查看装备, 那么就不查看 (对 GM 无影响)
	1	- 无视目标角色设置, 强制进行查看

返回值:
	操作成功则返回 1, 操作失败则返回 0

--------------------------------------------------------------

*countitemidx <背包序号>{,<角色编号>};
*countinventory <背包序号>{,<角色编号>};

获取指定背包序号的道具在背包中的数量. 

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回道具的数量, 操作失败则返回 0

--------------------------------------------------------------

*delitemidx <背包序号>{,<移除的数量>{,<角色编号>}};
*delinventory <背包序号>{,<移除的数量>{,<角色编号>}};

移除指定背包序号的道具, 支持指定移除数量以及目标角色编号. 
若被指定的道具已穿戴在目标角色身上, 那么该装备会被立刻脱下并移除.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

移除的数量:
	可选参数, 若不指定, 则表示你想删除指定道具的全部.

返回值:
	操作成功则返回 1, 操作失败则返回 0

--------------------------------------------------------------

*identifyidx <背包序号>{,<角色编号>};
*identifybyidx <背包序号>{,<角色编号>};

鉴定指定背包序号的道具.
只要背包序号合法, 哪怕道具已经被鉴定过, 该函数也会返回 1.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 操作失败则返回 0

--------------------------------------------------------------

*unequipidx <背包序号>{,<角色编号>};
*unequipinventory <背包序号>{,<角色编号>};

脱下指定背包序号的道具.
只要背包序号合法, 哪怕道具已被脱下, 该函数也会返回 1.
若指定的道具不是装备, 那么该函数将返回 0 (但不会报错, 也不会警告).

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 操作失败则返回 0

--------------------------------------------------------------

*equipidx <背包序号>{,<角色编号>};
*equipinventory <背包序号>{,<角色编号>};

穿戴指定背包序号的道具.
只要背包序号合法, 哪怕道具已被穿戴, 该函数也会返回 1.
若指定的道具不是装备, 那么该函数将返回 0 (但不会报错, 也不会警告).

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 操作失败则返回 0


--------------------------------------------------------------

*itemexists <物品编号/"物品名称">;
*existitem <物品编号/"物品名称">;

确认物品数据库中是否存在指定物品, 通常用于提高脚本的健壮性.

物品编号/"物品名称":
	多类型参数. 可以填写数值类型的道具编号, 或者字符串类型的道具名称.
	推荐使用道具编号, 相较而言结果会更加准确.

注意事项:
	查询时请避免填写 [字符串类型] 的道具编号, 
	因为这里的参数只要是字符串类型的, 都会走物品名称判断逻辑.

返回值:
	若物品指定的道具编号不存在于数据库中则返回 0,
	若物品存在且 [可堆叠] 则返回 [正数] 物品编号, [不可堆叠] 则返回 [负数] 物品编号

--------------------------------------------------------------

*renttime <EQI装备位置>,<增减的时间秒数>{,<角色编号>};
*setrenttime <EQI装备位置>,<增减的时间秒数>{,<角色编号>};
*resume <EQI装备位置>,<增减的时间秒数>{,<角色编号>};

增加/减少指定位置装备的租赁时间.
如果要减少租赁时间的话, 第二个参数请使用负数.

EQI装备位置:
	是指 EQI_* 开头的位置常量, 可参考 doc/script_commands.txt

增减的时间秒数:
	若需要减少时间的话, 请使用负数.

注意事项:
	input 指令会将所有小于 0 的用户输入数值变成 0.
	若您希望由玩家通过 input 指令来指定要减少的秒数, 那么需要加个负数符号.
	或者修改 conf/script_athena.conf 中 input_min_value 选项的值.

返回值:
	操作失败返回 0, 非 0 的正数表示成功增减后新的剩余时间秒数
	若指定位置没有穿戴装备, 或指定位置的装备并非租赁道具, 函数都会返回 0

--------------------------------------------------------------

*getequipidx <EQI装备位置>{,<角色编号>};

获取指定位置装备的背包序号. 注意该函数返回 0 不代表失败.

EQI装备位置:
	EQI_COMPOUND_ON (-1)      - Item slot that calls this script (In context of item script)
	EQI_ACC_L (0)             - Accessory 1
	EQI_ACC_R (1)             - Accessory 2
	EQI_SHOES (2)             - Footgear (shoes, boots)
	EQI_GARMENT (3)           - Garment (mufflers, hoods, manteaux)
	EQI_HEAD_LOW (4)          - Lower Headgear (beards, some masks)
	EQI_HEAD_MID (5)          - Middle Headgear (masks, glasses)
	EQI_HEAD_TOP (6)          - Upper Headgear
	EQI_ARMOR (7)             - Armor (jackets, robes)
	EQI_HAND_L (8)            - Left hand (weapons, shields)
	EQI_HAND_R (9)            - Right hand (weapons)
	EQI_COSTUME_HEAD_TOP (10) - Upper Costume Headgear
	EQI_COSTUME_HEAD_MID (11) - Middle Costume Headgear
	EQI_COSTUME_HEAD_LOW (12) - Lower Costume Headgear
	EQI_COSTUME_GARMENT (13)  - Costume Garment
	EQI_AMMO (14)    		  - Arrow/Ammunition
	EQI_SHADOW_ARMOR (15)     - Shadow Armor
	EQI_SHADOW_WEAPON (16)    - Shadow Weapon
	EQI_SHADOW_SHIELD (17)    - Shadow Shield
	EQI_SHADOW_SHOES (18)     - Shadow Shoes
	EQI_SHADOW_ACC_R (19)     - Shadow Accessory 2
	EQI_SHADOW_ACC_L (20)     - Shadow Accessory 1


返回值:
	-1 - 在指定的EQI装备位置找不到装备
	-2 - 填写的EQI装备位置无效
	-3 - 指定的角色编号无效, 或者目标玩家不在线
	其他大于等于 0 的数值则表示成功, 返回值就是所查位置装备的背包序号

--------------------------------------------------------------

*statuscalc;
*status_calc;

根据角色目前的装备、技能、状态以及其他各种加成, 重新执行计算玩家的能力.

不推荐使用:
	rAthena 已经推出了功能完全一致的指令 recalculatestat;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.
	此处的 statuscalc 和 status_calc 实际上是 recalculatestat 的别名, 以便兼容以前的部分脚本.

返回值:
	该指令无论执行成功与否, 都不会有返回值

--------------------------------------------------------------

*getequipexpiretick <EQI装备位置>{,<角色编号>};
*isrental <EQI装备位置>{,<角色编号>};

获取指定位置装备的租赁到期剩余秒数.

EQI装备位置:
	是指 EQI_* 开头的位置常量, 可参考 doc/script_commands.txt

返回值:
	-1 - 在指定的EQI装备位置找不到装备
	-2 - 填写的EQI装备位置无效
	-3 - 指定的角色编号无效, 或者目标玩家不在线
	-4 - 剩余秒数不合法 (比如: 道具早应该过期消失了, 但居然还在背包里)
	 0 - 此装备不是租赁装备, 永久有效
	其他大于 0 的数值则代表租赁到期的剩余秒数

--------------------------------------------------------------

*updateinventory {<角色编号>};

该指令用于重新下发关联玩家的背包数据给客户端.
涵盖角色背包每一个道具的每一个信息, 请避免高频调用或者循环调用.

--------------------------------------------------------------

*getinventoryinfo <道具的背包序号>,<要查看的信息类型>{,<角色编号>};

查询指定背包序号的道具详细信息.

道具的背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

要查看的信息类型:
	0   - 物品编号
	1   - 堆叠数量
	2   - 装备的穿戴位置
	3   - 精炼值
	4   - 是否已鉴定 (若已鉴定则返回 1, 未鉴定则返回 0)
	5   - 是否已损坏 (若已损坏则返回 1, 未损坏则返回 0)
	6   - 第一个卡槽的卡片编号
	7   - 第二个卡槽的卡片编号
	8   - 第三个卡槽的卡片编号
	9   - 第四个卡槽的卡片编号
	10  - 过期时间 (Unix时间戳, 0 表示永不过期)
	11  - 唯一编号 (unique_id)
	
	12  - 第一个随机属性的编号 (ROA_ID)
	13  - 第二个随机属性的编号 (ROA_ID)
	14  - 第三个随机属性的编号 (ROA_ID)
	15  - 第四个随机属性的编号 (ROA_ID)
	16  - 第五个随机属性的编号 (ROA_ID)
	
	17  - 第一个随机属性的值 (ROA_VALUE)
	18  - 第二个随机属性的值 (ROA_VALUE)
	19  - 第三个随机属性的值 (ROA_VALUE)
	20  - 第四个随机属性的值 (ROA_VALUE)
	21  - 第五个随机属性的值 (ROA_VALUE)
	
	22  - 第一个随机属性的参数 (ROA_PARAM)
	23  - 第二个随机属性的参数 (ROA_PARAM)
	24  - 第三个随机属性的参数 (ROA_PARAM)
	25  - 第四个随机属性的参数 (ROA_PARAM)
	26  - 第五个随机属性的参数 (ROA_PARAM)

	27  - 道具的绑定类型
	28  - 道具的附魔评级 (Grade Level)
	29  - 道具作为第二套快速切换装备时的穿戴位置
	30  - 道具是否被标记为最喜欢的道具 (0: 未标记; 1: 已标记)

装备的穿戴位置:
	如果为 0 则表示还没穿戴在身上, 位置请参考 EQP_* 开头的常量
	查询的信息类型 2 和 29 都是 EQP_* 开头的常量.

道具的绑定类型:
	Bound_None      -   没有绑定 (与 0 等价, 但更推荐用常量)
	Bound_Account   -   绑定账号的道具, 可放个人仓库, 全账号共享
	Bound_Guild     -   绑定公会的道具, 可放公会仓库与他人共享, 拥有物品的人离开公会后物品消失
	Bound_Party     -   绑定队伍的道具, 离开队伍后消失
	Bound_Char      -   绑定角色的道具, 不能放个人仓库

注意事项:
	从 v1.0.6 版本开始,
	若查询的信息类型是 11 (装备的唯一编号),
	那么返回值既可以存放在数值型变量, 也可以存放在字符串型变量.

返回值:
	获取失败则返回 -1, 获取成功则返回你所查询的信息

--------------------------------------------------------------

*getcartinfo <道具的手推车序号>,<要查看的信息类型>{,<角色编号>};

查询指定手推车序号的道具详细信息.

道具的手推车序号:
	可以通过 getcartlist 脚本指令的 @inventorylist_idx[] 数组来获得.

要查看的信息类型:
	请参考 getinventoryinfo 的参数定义, 它们完全一致.
	
	以下信息类型, 对于手推车道具没有意义:

		29 - 道具作为第二套快速切换装备时的穿戴位置
		     因为手推车中的道具不能作为第二套快速切换装备
		30 - 道具是否被标记为最喜欢的道具
		     因为手推车中的道具不能被标记为最喜欢的道具

返回值:
	获取失败则返回 -1, 获取成功则返回你所查询的信息

--------------------------------------------------------------

*getguildstorageinfo <道具的公会仓库序号>,<要查看的信息类型>{,<角色编号>};

查询指定公会仓库序号的道具详细信息.

道具的公会仓库序号:
	可以通过 getguildstoragelist 脚本指令的 @inventorylist_idx[] 数组来获得.

要查看的信息类型:
	请参考 getinventoryinfo 的参数定义, 它们完全一致.
	
	以下信息类型, 对于公会仓库道具没有意义:

		29 - 道具作为第二套快速切换装备时的穿戴位置
		     因为公会仓库中的道具不能作为第二套快速切换装备
		30 - 道具是否被标记为最喜欢的道具
		     因为公会仓库中的道具不能被标记为最喜欢的道具

返回值:
	获取失败则返回 -1, 获取成功则返回你所查询的信息

--------------------------------------------------------------

*getstorageinfo <道具的个人仓库/扩充仓库序号>,<要查看的信息类型>{{,<仓库编号>},<角色编号>};

查询指定个人仓库/扩充仓库序号的道具详细信息.

道具的个人仓库/扩充仓库序号:
	可以通过 getstoragelist 脚本指令的 @inventorylist_idx[] 数组来获得.

要查看的信息类型:
	请参考 getinventoryinfo 的参数定义, 它们完全一致.
	
	以下信息类型, 对于个人仓库/扩充仓库道具没有意义:

		29 - 道具作为第二套快速切换装备时的穿戴位置
		     因为个人仓库/扩充仓库中的道具不能作为第二套快速切换装备
		30 - 道具是否被标记为最喜欢的道具
		     因为个人仓库/扩充仓库中的道具不能被标记为最喜欢的道具

仓库编号:
	该指令支持获取扩充仓库的内容, 因此你需要在查询时指定仓库编号.

	0 - 个人仓库 (每个玩家都会有的默认仓库)
	X - 扩充仓库 (其他非 0 的定义在 conf/inter_athena.yml 中的有效仓库编号)

返回值:
	获取失败则返回 -1, 获取成功则返回你所查询的信息

--------------------------------------------------------------

*setinventoryinfo <道具的背包序号>,<要设置的信息类型>,<值>{{,<标记位>},<角色编号>};

设置指定背包序号道具的详细信息.
值得注意的是, 这里修改的主要是每个玩家各有不同的那些道具的属性信息,
例如: 道具插入的卡片, 道具的精炼值等等

道具的背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

要设置的信息类型:
	3   - 精炼值
	4   - 是否已鉴定 (若已鉴定则返回 1, 未鉴定则返回 0)
	5   - 是否已损坏 (若已损坏则返回 1, 未损坏则返回 0)
	6   - 第一个卡槽的卡片编号
	7   - 第二个卡槽的卡片编号
	8   - 第三个卡槽的卡片编号
	9   - 第四个卡槽的卡片编号
	10  - 过期时间 (Unix时间戳, 0 表示永不过期)
	11  - 唯一编号 (unique_id)
	
	12  - 第一个随机属性编号 (ROA_ID)
	13  - 第二个随机属性编号 (ROA_ID)
	14  - 第三个随机属性编号 (ROA_ID)
	15  - 第四个随机属性编号 (ROA_ID)
	16  - 第五个随机属性编号 (ROA_ID)
	
	17  - 第一个随机属性的值 (ROA_VALUE)
	18  - 第二个随机属性的值 (ROA_VALUE)
	19  - 第三个随机属性的值 (ROA_VALUE)
	20  - 第四个随机属性的值 (ROA_VALUE)
	21  - 第五个随机属性的值 (ROA_VALUE)
	
	22  - 第一个随机属性的参数 (ROA_PARAM)
	23  - 第二个随机属性的参数 (ROA_PARAM)
	24  - 第三个随机属性的参数 (ROA_PARAM)
	25  - 第四个随机属性的参数 (ROA_PARAM)
	26  - 第五个随机属性的参数 (ROA_PARAM)

	27  - 道具的绑定类型
	28  - 道具的附魔评级 (Grade Level)
	29  - 道具作为第二套快速切换装备时的穿戴位置
	30  - 道具是否被标记为最喜欢的道具 (0: 未标记; 1: 已标记)

卡片编号:
	若将卡片编号设置为 0 则视为删除卡片.
	需要注意的是, 卡片将会被凭空移除, 不会留下任何日志记录.

随机属性编号:
	此处的编号是 item_randomopt_db.yml 数据库中的 VAR_* 开头的常量,
	但需要注意的是从 yml 文件中获得的常量需要添加 RDMOPT_ 前缀才是最后生效的最终常量名,
	例如: VAR_MAXHPAMOUNT 最终常量名是 RDMOPT_VAR_MAXHPAMOUNT.
	
	若将此处的编号设置为 0, 那么将会同时清空对应的 ROA_VALUE 和 ROA_PARAM 选项的值.

道具的绑定类型:
	Bound_None      -   没有绑定 (与 0 等价, 但更推荐用常量)
	Bound_Account   -   绑定账号的道具, 可放个人仓库, 全账号共享
	Bound_Guild     -   绑定公会的道具, 可放公会仓库与他人共享, 拥有物品的人离开公会后物品消失
	Bound_Party     -   绑定队伍的道具, 离开队伍后消失
	Bound_Char      -   绑定角色的道具, 不能放个人仓库

过期时间:
	当您要设置的类型是 10 (过期时间)时, 一定要注意这是个Unix时间戳.
	
	若将值设为 60 秒, 那么道具会因为已过期被立刻删掉:
		setinventoryinfo(<背包序号>, 10, 60);	// 错误

	延长道具 60 秒有效期的正确写法是:
		setinventoryinfo(<背包序号>, 10, gettimetick(2) + 60);	// 正确

标记位:
	每次调用该指令时会调用按需重算角色属性, 且必定重新发送完整背包数据给客户端
	但如果因为你需要循环处理背包中的全部道具, 那么你有 100 个道具, 
	服务器就需要把 100 个道具信息下发 100 次给客户端, 这是非常低效且不合理的.
	
	原则上尽量避免大量循环调用 setinventoryinfo 指令,
	但如果无法避免, 那么可以考虑通过传递特殊标记位, 来在循环过程中抑制能力重算
	或者背包数据的刷新行为, 在循环结束后再触发一次相关行为.
	
		&1 : 跳过角色能力重算
		&2 : 跳过全量刷新角色的背包数据
		&4 : 忽略卡片插入合理性的校验 (插入的道具类型必须是卡片, 卡片位置和装备位置符合)
		&8 : 插入卡片无需写入 picklog 记录 (凭空生成)
	
	若标记位设置为 0 则表示维持默认行为.
	
	--------
	
	提示信息: 
	
	- 使用 &1 标记位的循环结束后, 可以使用 recalculatestat(); 触发角色能力重算
	- 使用 &2 标记位的循环结束后, 可以使用 updateinventory(); 重现发送最新背包数据给客户端

返回值:
	-1 - 设置失败, 插入的卡片不合法
	 0 - 设置失败
	 1 - 设置成功

--------------------------------------------------------------

*statuscheck <状态编号>{,<游戏单位编号>};
*sc_check <状态编号>{,<游戏单位编号>};

该指令用于判断状态是否存在, 并取得相关的状态参数.

不推荐使用:
	rAthena 已经推出了功能近似的指令 getstatus;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

状态编号:
	每一个增益或者减益状态都有一个编号, 脚本中一般用常量表示.
	比如负重超过 50% 的状态编号是: SC_WEIGHT50
	这部分的常量定义可以在: src/map/status.hpp 中的 sc_type 定义中找到.

游戏单位编号:
	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>

信息通过变量返回:
	当返回值为 1 的时候, 可以通过以下变量来读取状态的参数:

	@sc_val1		状态的第 1 个参数值 (如果是技能对应的状态的话, 往往这个参数都是技能等级)
	@sc_val2		状态的第 2 个参数值
	@sc_val3		状态的第 3 个参数值
	@sc_val4		状态的第 4 个参数值
	@sc_tickleft	状态的剩余时间 (单位为毫秒, 若为 -1 表示永久有效)

注意事项:
	从 v1.0.7 版本开始 @sc_tickleft 的上限已经[不会再被限制]到 2147483647 毫秒.

返回值:
	获取成功则返回 1, 角色没有该状态则返回 0, 其他错误返回 -1

--------------------------------------------------------------

*renttimeidx <背包序号>,<增减的时间秒数>{,<角色编号>};

增加/减少指定背包序号道具的租赁时间.
如果要减少租赁时间的话, 第二个参数请使用负数.

该指令与 renttime 近似, 只是 renttime 操作的是某个已穿戴的装备,
而 renttimeidx 指令可以通过背包序号来指定要调整的物品.

背包序号:
	可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

增减的时间秒数:
	若需要减少时间的话, 请使用负数.

注意事项:
	input 指令会将所有小于 0 的用户输入数值变成 0.
	若您希望由玩家通过 input 指令来指定要减少的秒数, 那么需要加个负数符号.
	或者修改 conf/script_athena.conf 中 input_min_value 选项的值.

返回值:
	操作失败返回 0, 非 0 的正数表示成功增减后新的剩余时间秒数
	若指定位置没有穿戴装备, 或指定位置的装备并非租赁道具, 函数都会返回 0

--------------------------------------------------------------

*party_leave {<角色编号>};

使当前角色或指定角色退出队伍.

不推荐使用:
	rAthena 已经推出了功能近似的指令 party_delmember;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

角色编号:
	若不指定角色编号, 那么将会使执行该指令的玩家退出队伍.

返回值:
	若指定的角色不在线或不在队伍中则返回 0,
	若角色成功退出队伍则返回 1

--------------------------------------------------------------

*script4each <"{脚本}">,<脚本执行范围>{,<动态参数>...};
*script4eachmob <"{脚本}">,<脚本执行范围>{,<动态参数>...};
*script4eachnpc <"{脚本}">,<脚本执行范围>{,<动态参数>...};

对指定范围的单位执行相同的一段脚本.
若使用 script4each 指令, 则执行 <脚本> 的玩家将会成为其默认关联玩家.

脚本的执行范围:
	0 - 全服单位								例: script4each "{<脚本>}",0;
	1 - 指定地图上的全部单位					例: script4each "{<脚本>}",1,<"地图名称">;
	2 - 以地图某个点为中心半径距离内的单位		例: script4each "{<脚本>}",2,<"地图名称">,<中心坐标x>,<中心坐标y>,<范围>;
	3 - 指定玩家所在的队伍中的全部队伍成员		例: script4each "{<脚本>}",3,<角色编号>;
	4 - 指定玩家所在的公会中的全部公会成员		例: script4each "{<脚本>}",4,<角色编号>;
	5 - 指定区域内的全部单位					例: script4each "{<脚本>}",5,<"地图名称">,<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>;
	6 - 指定队伍中的全部队伍成员				例: script4each "{<脚本>}",6,<队伍编号>;
	7 - 指定公会中的全部公会成员				例: script4each "{<脚本>}",7,<公会编号>;
	
	其中 3,4,6,7 仅支持被 script4each 使用, 无法对 script4eachmob 和 script4eachnpc 生效.

可无视外层大括号:
	从 Pandas v1.0.1 版本开始, {<脚本>} 参数中最外层的大括号可以被忽略.

	例如, 以前必须加外层大括号, 否则会报错:

		script4each "{ getitem 501, 10; }", 0;

	现在, 可以直接忽略最外层大括号, 简写变成:

		script4each "getitem 501, 10;", 0;

通过变量返回 GID:
	当 script4each 系列指令即将在某个单位身上执行脚本之前, 会将该单位的 GID 保存到 $@gid
	通过 $@gid 变量保存的内容, 就能利用 unit* 系列指令来操作目标单位.
	
	例如, 以下代码会让全服魔物立刻说出自己的名字:

		script4eachmob "{ unittalk $@gid, getunitname($@gid); }", 0;

双引号转义: 
	如果 <脚本> 参数中有使用到双引号的话, 需要在双引号的左侧使用 \ 来进行转义.
	
	假设我们希望让全服玩家执行这样一段脚本: 
	
		announce "角色名称: " + strcharinfo(0) + " | 角色编号: " + getcharid(0), 0;
	
	那么上述脚本在使用 script4each 系列指令来执行的时候, <脚本> 参数内的双引号都需要加 \ 来转义,
	转义操作很简单, 直接将 " 替换成 \" 即可, 最后调用 script4each 时用法如下:
	
		script4each "{ announce \"角色名称: \" + strcharinfo(0) + \" | 角色编号: \" + getcharid(0), 0; }", 0;
	
字符串变量拼接特别注意:	
	角色名默认也允许玩家使用双引号, 在这种情况下当您使用 strcharinfo(0) 作为脚本的一部分,
	或者引用其他字符串变量作为脚本的一部分但其内容中可能包含双引号的时候, 也需要对这些字符串变量的内容进行双引号转义.
	
	比较推荐的方法是自己包装一个转义函数, 来将 " 替换成 \", 参考代码如下:
	
		function	script	esc_double_quotation	{
			.@text$ = getarg(0, "");
			.@text$ = replacestr(.@text$, "\"", "\\\"");
			return .@text$;
		}
	
	然后在拼接 script4each 用于执行的脚本时, 参与拼接的字符串变量都套上它:
	
		script4each "{ announce \"角色名称: \" + esc_double_quotation(strcharinfo(0)) + \" | 角色编号: \" + getcharid(0), 0; }", 0;
	
	这样就是比较完备和严谨的做法了, 哪怕角色名带双引号也不会导致脚本解析失败.
	之所以不推荐使用 escape_sql 指令来进行转义, 是因为它除了转义双引号还会处理单引号等其他符号, 而我们只关心双引号.

支持调用事件标签:
	从 Pandas v1.0.2 版本开始, {<脚本>} 参数支持直接调用指定的 NPCNAME::EVENT 事件标签.
	
	有时我们的 {<脚本>} 参数需要写入大量复杂的条件判断, 若只写成一行,
	那么可读性会很差, 大量的转义操作都过于繁琐.
	
	现在开始你可以将复杂的脚本逻辑直接定义到某个 NPCNAME::EVENT 事件标签中,
	并在 script4each 系列指令中通过 {<脚本>} 参数直接调用, 方法如下:
	
	-	script	elabel_demo	-1,{
	end;
	OnLoveTest:
		unittalk $@gid, "我的名称是: " + getunitname($@gid);
	end;
	}
	
	prontera,150,150,4	script	elabel_test	123,{
		// 使全服玩家执行 elabel_demo::OnLoveTest 事件标签对应的脚本
		script4each "elabel_demo::OnLoveTest",0;
	}

注意事项:
	请注意给该系列指令指定 <脚本的执行范围> 使尽量合理.
	例如服务端默认情况下加载的 NPC 脚本, 总共就包含 2 万个 NPC 单位,
	若频繁使用 script4eachnpc 且将 <脚本的执行范围> 设置为 0 的话, {<脚本>} 就会在 2 万个 NPC 上频繁执行.
	使用不当的话, 会比较容易导致服务器出现卡顿的现象.
	
	若使用 NPCNAME::EVENT 方式调用 script4each 系列指令的话, 双引号内 NPCNAME::EVENT 的左右请不要加空格:

		script4each "elabel_demo::OnLoveTest",0;	// 正确示例
		script4each " elabel_demo::OnLoveTest",0;	// 错误示例: elabel_demo 左侧有个空格
		script4each "elabel_demo::OnLoveTest ",0;	// 错误示例: OnLoveTest 右侧有个空格

	否则可能会找不到对应的 NPCNAME::EVENT, 从而导致引擎将 {<脚本>} 的内容当做常规脚本进行语法解析, 最终报错.

返回值:
	该指令无论成功失败, 都不会有返回值

--------------------------------------------------------------

*searcharray <数组变量>,<要查找的字符串或数值>;

查询数组中第一次出现待查询内容的索引序号, 使用它来搜索数组内容很方便.

不推荐使用:
	rAthena 已经推出了功能近似的指令 inarray;
	建议优先使用 rAthena 官方指令, 以便确保最大的脚本兼容性.

返回值:
	若查不到结果则返回 -1, 否则返回大于等于 0 的索引序号

--------------------------------------------------------------

*getsameipinfo {<"IP地址">{,<"地图名">}};

获得某个指定 IP 在线的玩家信息.
若不指定任何参数, 则默认查询当前脚本关联角色的 IP 地址.

IP地址:
	可选参数, 若需要指定的话请填写标准的 4 段式 IP 地址,
	例如: getsameipinfo "114.114.114.114"

地图名:
	可选参数, 若想指定此参数则必须先指定<"IP地址">
	地图名不需要添加 .gat 后缀

信息通过变量返回:
	@sameip_aid[]		该 IP 在线的玩家账号编号数组 - 数值型数组
	@sameip_cid[]		该 IP 在线的玩家角色编号数组 - 数值型数组
	@sameip_name$[]		该 IP 在线的玩家角色名称数组 - 字符型数组

返回值及 @sameip_amount 变量都会赋予目前使用指定IP登录的玩家个数.

提示信息:
	官方自带的 getcharip 脚本指令可以获得某个玩家的 IP 地址, 
	配合这个指令就能知道对方相同 IP 下有几个角色在线.

返回值:
	出错返回 -1, 其他含 0 正整数表示查到的此 IP 的在线玩家数

示例代码:
	// 查询全服范围内, 和当前角色 IP 相同的玩家信息和数量
	getsameipinfo(getcharip());
	
	// 查询普隆德拉地图中, 和当前角色 IP 相同的玩家信息和数量
	getsameipinfo(getcharip(), "prontera");
	
	// 查询和当前角色相同的地图中, 和当前角色 IP 相同的玩家信息和数量
	getsameipinfo(getcharip(), strcharinfo(3));

--------------------------------------------------------------

*logout <登出理由>{,"<角色名称>"|<账号编号>|<角色编号>};

使指定的角色立刻登出游戏(踢下线), 此处的"登出理由"只能做参考,
不同的理由编号会让客户端给玩家显示不同的 msgstringtable 提示文本:

登出理由:
	0 = BAN_UNFAIR
	1 = 服务器已关闭 -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = 连接超时 / 网络延迟不稳定 -> MsgStringTable[241]
	4 = 服务器已经满员 -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = 被 GM 踢下线 -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	111 = 与服务器断开连接 -> MsgStringTable[3]

返回值:
	该指令无论成功失败, 都不会有返回值

--------------------------------------------------------------

*warppartyrevive "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};
*warpparty2 "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};

该指令的用法与 warpparty 完全一样, 都是将指定队伍全员传送到指定目的地.

区别在于: 
	warpparty 对已经死亡的队友则无效 (死亡的队友会被留在原地),
	warppartyrevive 对已经死亡的队友有效 (队友会被立刻复活, 并一起被传送走).

返回值:
	该指令无论成功失败, 都不会有返回值

--------------------------------------------------------------

*getareagid <返回数组>,<搜索范围>{,<动态参数>...};

获取指定范围内特定类型单位的全部 GID, 并返回到指定的数组中.

返回数组:
	必填项, 需要指定一个用于返回GID的数值型数组
	若给定的是角色相关变量 (比如角色变量级的数组), 那么脚本必须关联到某个玩家
	若给定的是系统相关变量 (比如地图服务器的数组), 那么脚本无需关联到某个玩家

搜索范围:
	指定地图上的全部玩家				- getareagid <返回数组>,0,<想搜索的单位类型>,<"地图名称">;
	以地图某个点为中心半径距离内的玩家	- getareagid <返回数组>,1,<想搜索的单位类型>,<"地图名称">,<中心坐标x>,<中心坐标y>,<范围>;
	指定区域内的全部玩家				- getareagid <返回数组>,2,<想搜索的单位类型>,<"地图名称">,<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>;

想搜索的单位类型:
	BL_PC		- 玩家角色单位
	BL_MOB		- 魔物单位
	BL_PET		- 宠物单位
	BL_HOM		- 人工生命体单位
	BL_MER		- 佣兵单位
	BL_ITEM		- 物品单位
	BL_SKILL	- 技能单位
	BL_NPC		- NPC单位
	BL_CHAT		- 聊天室单位
	BL_ELEM		- 元素精灵单位
	BL_ALL		- 全部单位类型

地图名称:
	指定的地图名称, 比如 "prontera" 表示普隆德拉
	地图名称可以设置为 "this", 表示获取当前脚本关联玩家所在的地图

注意事项:
	该指令被重新设计过, 参数相比 rAthenaCN 老版本有所不同, 使用时需要注意.

返回值:
	操作失败返回 -1, 其他含 0 正整数表示搜索到的 GID 数量

--------------------------------------------------------------

*getiteminfo(<物品编号>,<查询的信息类型>{,<用于返回附加数据的数组>})

在 rAthena 原来的参数代码基础上, 熊猫模拟器新增了一些查询信息类型.

注意事项:
	从 Pandas v1.0.1 版本开始, -5 类型的返回值不再直接返回支持捕捉的魔物编号

查询的信息类型 (注意: 传入参数是负数):
	-1	-	是否可精炼
	-2	-	交易限制掩码
	-3	-	避免物品被玩家主动使用而消耗
	-4	-	避免物品被作为发动技能的必要道具而消耗		
	-5	-	是否为宠物捕捉道具
	-6	-	是否在其使用脚本中调用了 callfunc 指令
	-7	-	返回物品的 "使用脚本" 字符串
	-8	-	返回物品的 "装备脚本" 字符串
	-9	-	返回物品的 "卸装脚本" 字符串

返回值:
	-1	-	返回 1 表示可以精炼, 0 表示不能精炼
	-2	-	返回该物品在 item_trade 数据库中第二列定义的值
	-3	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-4	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-5	-	返回 1 表示这是一个宠物捕捉道具 (<用于返回附加数据的数组> 将返回支持捕捉的魔物编号), 0 表示不是
	-6	-	返回 0 表示没有调用 callfunc 函数, 返回 1 表示调用了 callfunc 函数
	-7	-	返回字符串内容, 包含物品的 "使用脚本" 字符串
	-8	-	返回字符串内容, 包含物品的 "装备脚本" 字符串
	-9	-	返回字符串内容, 包含物品的 "卸装脚本" 字符串
	
	其中 -5 和 -6 若返回 -2 则表示未编译此功能
	其中 -7 到 -9 若返回 UnCompiled 字符串则表示未编译此功能
	以上全部信息类型, 若返回 -1 表示这个物品编号是不存在或无效的.

用于返回附加数据的数组:
	目前仅 -5 类型会使用到, 如果查询 -5 类型的时候指定 <用于返回附加数据的数组>
	那么该道具支持捕捉的魔物编号将会填充到这个数组中 (注意: 只能使用数值型数组).

示例代码:
	prontera,150,150,5	script	查询抓宠道具	123,{
		mes "[查询抓宠道具]";
		mes "请输入要查询的道具编号.";
		next;
		
		input .@nameid;
		cleararray .@taming_mobid, 0, getarraysize(.@taming_mobid);
		.@result = getiteminfo(.@nameid, -5, .@taming_mobid);
		
		if (.@result == -1) {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 道具编号不存在或无效";
		}
		else if (.@result == -2) {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 此功能未编译到代码中";
		}
		else if (.@result == 1) {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 这是抓宠道具, 能抓:";
			mes "==========";
			for (.@i = 0; .@i < getarraysize(.@taming_mobid); .@i++) {
				mes "> 魔物编号: " + .@taming_mobid[.@i];
			}
		}
		else {
			mes "[查询抓宠道具]";
			mes "道具编号: " + .@nameid;
			mes "查询结论: 这应该不是抓宠道具";
		}
		close;
	}

--------------------------------------------------------------

*processhalt {<是否设置中断>};

该指令只能在事件处理脚本中使用.
设置中断可以打断本次事件脚本结束后的源代码后续逻辑.

每个事件的源代码后续逻辑各有不同, 且只能用于部分事件, 详情请参考事件说明文档.

是否设置中断:
	可选参数, 填写 0 表示取消中断, 填写 1 表示设置中断.
	若不携带该参数则默认为: 1 - 设置中断

返回值:
	该指令无论成功失败, 都不会有返回值

--------------------------------------------------------------

*settrigger <事件的常量名称>,<触发行为>;

使用该指令可以设置某个事件或过滤器的触发行为

事件的常量名称:
	每个事件或过滤器在代码中都有自己的常量名称, 对照如下:
	
	NPCE_LOGIN				-	OnPCLoginEvent
	NPCE_LOGOUT				-	OnPCLogoutEvent
	NPCE_LOADMAP			-	OnPCLoadMapEvent
	NPCE_BASELVUP			-	OnPCBaseLvUpEvent
	NPCE_JOBLVUP			-	OnPCJobLvUpEvent
	NPCE_DIE				-	OnPCDieEvent
	NPCE_KILLPC				-	OnPCKillEvent
	NPCE_KILLNPC			-	OnNPCKillEvent
	NPCE_STATCALC			-	OnPCStatCalcEvent
	
	NPCF_IDENTIFY			-	OnPCIdentifyFilter
	NPCF_ENTERCHAT			-	OnPCInChatroomFilter
	NPCF_INSERT_CARD		-	OnPCInsertCardFilter
	NPCF_USE_ITEM			-	OnPCUseItemFilter
	NPCF_USE_SKILL			-	OnPCUseSkillFilter
	NPCF_ROULETTE_OPEN		-	OnPCOpenRouletteFilter
	NPCF_VIEW_EQUIP			-	OnPCViewEquipFilter
	NPCF_EQUIP				-	OnPCEquipFilter
	NPCF_UNEQUIP			-	OnPCUnequipFilter
	NPCF_CHANGETITLE		-	OnPCChangeTitleFilter
	NPCF_SC_START			-	OnPCBuffStartFilter
	
	NPCE_KILLMVP			-	OnPCKillMvpEvent
	NPCE_IDENTIFY			-	OnPCIdentifyEvent
	NPCE_INSERT_CARD		-	OnPCInsertCardEvent
	NPCE_USE_ITEM			-	OnPCUseItemEvent
	NPCE_USE_SKILL			-	OnPCUseSkillEvent
	NPCE_EQUIP				-	OnPCEquipEvent
	NPCE_UNEQUIP			-	OnPCUnequipEvent

	NPCX_SC_START			-	OnPCBuffStartExpress
	NPCX_SC_END				-	OnPCBuffEndExpress
	NPCX_ENTERMAP			-	OnPCEnterMapExpress
	NPCX_PROGRESSABORT		-	OnPCProgressAbortExpress

触发行为:
	EVENT_TRIGGER_DISABLED	- 禁止触发此事件或过滤器
	EVENT_TRIGGER_ONCE		- 允许下次触发此事件或过滤器
	EVENT_TRIGGER_EVER		- 允许永久触发此事件或过滤器

--------------------------------------------------------------

*messagecolor "<消息文本>"{,"<文本颜色代码>",<发送目标>,<游戏单位编号>};

使用该指令可以发送指定颜色的消息文本到聊天窗口中.
除了发送者以外的其他角色可以见到消息发送者角色头上顶着文本气泡.

消息文本:
	消息的正文, 字符串类型, 没什么特别的.

文本颜色代码:
	可选参数, 默认发送的字体颜色为白色.
	该参数使用 RRGGBB 格式的字符串来传递色值, 例如红色是: "ff0000"

发送目标:
	bc_all  : 全服务器的在线玩家都可见.
	bc_map  : 与发送者处于相同地图的玩家都可见.
	bc_area : 发送者视野范围内的玩家可见 (默认值).
	bc_self : 仅发送者自己可见.

游戏单位编号:
	默认情况下的发送者就是使用该指令脚本所关联的玩家,
	必要的情况下您可以使用这个参数来指定其他的发送者, 以便达到想要的效果.

	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>

--------------------------------------------------------------

*copynpc "<复制出来的新NPC所在地图名称>,<X坐标>,<Y坐标>,<朝向编号>","duplicate(<来源NPC名称>)","<复制出来的新NPC名称>","<图档外观编号>";
*copynpc "<复制出来的新NPC所在地图名称>",<X坐标>,<Y坐标>,<朝向编号>,"<来源NPC名称>","<复制出来的新NPC名称>",<图档外观编号>;

使用该指令可以复制指定的 NPC 到一个新的位置.
该指令从 v1.0.1 版本开始, 拥有两个不同的参数版本可供随意选择, 程序将根据参数的个数进行自动识别.

四参数版本:

	需要携带 4 个字符串参数, 参数的内容需要脚本作者进行准确的拼接操作.

	参数看起来很多, 实际上是由 4 个字符串参数组成的,
	这 4 个字符串与使用 duplicate 进行静态复制时候的四个用 %TAB% 分隔的内容是一样的.

	参数说明:
		第一个参数: 字符串类型	-	"<复制出来的新NPC所在地图名称>,<X坐标>,<Y坐标>,<朝向编号>"
		第二个参数: 字符串类型	-	"duplicate(<来源NPC名称>)"
		第三个参数: 字符串类型	-	"<复制出来的新NPC名称>"
		第四个参数: 字符串类型	-	"<图档外观编号>"

	举例说明:
		假设有以下 NPC 我们想把它复制一个新的出来:

			prontera,146,99,2	script	PVP管理员::PVPCOPYTEST	123,{
				mes "[PVP管理员]";
				mes "场地正在修理, 请稍后再来...";
				close;
			}

		通常的做法是在脚本中, 使用 duplicate 指令进行静态复制, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理员#1	123
		
		现在你可以使用 copynpc 脚本指令, 将上面这一行静态复制代码按 %TAB% 分割为4个字段,
		然后以字符串形式传递给 copynpc 脚本指令, 如:
		
			copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理员#2","123";
			
			这里第二个参数支持简化 duplicate 关键字, 可以用以下语句实现同样的效果:
			
			copynpc "prontera,156,99,2","PVPCOPYTEST","PVP管理员#2","123";
		
		同时此函数支持返回复制出来的新 NPC 的 GID, 方便你使用 unit 系列指令对其进行操作, 如:
		
			.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理员#3","123");
			unittalk .@gid, "我是新克隆出来的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要复制一个副本中的 NPC, 那么需要在用到地图名称的地方使用 instance_mapname 进行转换,
		原始 NPC 的名称也需要用 instance_npcname 进行转换, 如:
		
			.@w1$ = instance_mapname("1@tower") + ",156,99,2";
			.@w2$ = "duplicate(" + instance_npcname("PVPCOPYTEST") + ")";
			.@w3$ = "PVP管理员#4";
			.@w4$ = "123";
			
			copynpc .@w1$, .@w2$, .@w3$, .@w4$;

七参数版本:

	需要携带 7 个参数, 参数的内容可以直接用对应类型的变量直接传递, 更方便理解.
	
	参数说明:
		第一个参数: 字符串类型	-	"<复制出来的新NPC所在地图名称>"
		第二个参数: 数值类型	-	<X坐标>
		第三个参数: 数值类型	-	<Y坐标>
		第四个参数: 数值类型	-	<朝向编号>
		第五个参数: 字符串类型	-	"<来源NPC名称>"
		第六个参数: 字符串类型	-	"<复制出来的新NPC名称>"
		第七个参数: 数值类型	-	<图档外观编号>

	举例说明:
		假设有以下 NPC 我们想把它复制一个新的出来:

			prontera,146,99,2    script    PVP管理员::PVPCOPYTEST    123,{
				mes "[PVP管理员]";
				mes "场地正在修理, 请稍后再来...";
				close;
			}

		通常的做法是在脚本中, 使用 duplicate 指令进行静态复制, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理员#1	123
		
		现在你可以使用 copynpc 脚本指令直接复制:
		
			copynpc "prontera",156,99,2,"duplicate(PVPCOPYTEST)","PVP管理员#2",123;
			
			这里第二个参数支持简化 duplicate 关键字, 可以用以下语句实现同样的效果:
			
			copynpc "prontera",156,99,2,"PVPCOPYTEST","PVP管理员#2",123;
		
		同时此函数支持返回复制出来的新 NPC 的 GID, 方便你使用 unit 系列指令对其进行操作, 如:
		
			.@gid = copynpc("prontera",156,99,2,"PVPCOPYTEST","PVP管理员#3",123);
			unittalk .@gid, "我是新克隆出来的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要复制一个副本中的 NPC, 那么需要在用到地图名称的地方使用 instance_mapname 进行转换,
		原始 NPC 的名称也需要用 instance_npcname 进行转换, 如:
		
			copynpc instance_mapname("1@tower"),156,99,2,instance_npcname("PVPCOPYTEST"),"PVP管理员#4",123;

公用说明:

	返回值:
		复制成功则返回复制出来的新 NPC 的 GID, 失败则返回 0

	注意事项:
		复制商店类型的 NPC 时, 来源 NPC 和目标 NPC 它们之间的道具列表是相互独立的.
		
		若指定了一个无效的外观编号, 那么地图服务器虽然会报 status_set_viewdata 错误,
		但是实际上 NPC 还是会复制成功 (只不过你看不见它).
		此时可以用 setunitdata 调整这个 NPC 的 UNPC_DISPLAY 参数, 重新给他一个外观.

--------------------------------------------------------------

*gettimefmt <"时间格式化标准">{,<要转换的秒数>{,<是否格式化成 UTC 时间>}};

时间格式化标准:
	与 gettimestr 函数的第一个参数完全一样.
	可以参考: https://www.runoob.com/cprogramming/c-function-strftime.html

要转换的秒数:
	可选参数, 如果你指定了一个秒数, 那么指令将不会转换当前系统时间, 而是转换你给定的时间

是否格式化成 UTC 时间:
	可选参数, 默认值为 0, 填写 1 表示是. 如果格式化成 UTC 时间, 则不会包含时区.
	
	dispbottom gettimefmt("%H:%M:%S", 10);		// 在北京的话, 返回: 08:00:10 (北京时区是 UTC + 08:00:00)
	dispbottom gettimefmt("%H:%M:%S", 10, 1);	// 返回: 00:00:10

返回值:
	成功则返回被格式化的时间, 失败则返回空字符串

--------------------------------------------------------------

*mpet <魔物编号>{,<魔物编号>...}
*multicatchpet <魔物编号>{,<魔物编号>...}

与 pet / catchpet 指令类似, 但可以设定多个支持捕捉的魔物编号

魔物编号:
	必须是存在于 db/{pre-}re/pet_db.yml 中定义的魔物编号
	没有定义在 pet_db.yml 的魔物, 我们无法知道它的食物和饥饿率等数据

返回值:
	该指令无论成功失败, 都不会有返回值

--------------------------------------------------------------

*selfdeletion {<自毁策略>}

该指令与 unloadnpc 类似, 但可以控制自毁当前 NPC,
包括一些更细腻的自毁时机控制. 哪怕 NPC 没有关联到玩家, 也可以完成自毁.

自毁策略:
	SELFDEL_NOW       - 控制当前 NPC 终止全部正在与其交互的玩家对话, 并立刻自毁 (默认值)
	SELFDEL_WAITFREE  - 当最后一个正在与其交互的玩家对话结束后, 再进行自毁 (无论是否有工作中的定时器)
	SELFDEL_CANCEL    - 取消 SELFDEL_WAITFREE 设置的自毁标记

返回值:
	该指令无论成功失败, 都不会有返回值

场景建议:
	常用于配合 copynpc 指令, 实现进行挖矿\钓鱼\开宝箱等与 NPC 对话完毕后 NPC 会消失的场景.

注意事项:
	在 NPC 中 callfunc 某个 function, 在这个 function 中调用的 selfdeletion 将对调用者 NPC 生效.

--------------------------------------------------------------

*setchartitle <称号ID>{,<角色编号>};

设置指定玩家角色的称号ID
该指令只在客户端封包版本大于等于 20150513 的时候有效.

称号ID:
	称号ID在客户端的 data\luafiles514\lua files\datainfo\titletable.lub 中获取.
	服务端并不清楚客户端会将某个称号ID呈现出什么样的字符串.

返回值:
	设置成功则返回 1, 设置失败则返回 0

--------------------------------------------------------------

*getchartitle {<角色编号>};

获得指定玩家角色的称号ID
该指令只在客户端封包版本大于等于 20150513 的时候有效.

返回值:
	设置成功则返回目标玩家的称号ID (若为 0 则表示此玩家没有称号)
	获取失败则返回 -1

--------------------------------------------------------------

*npcexists "<NPC名称>"{,<用于保存 GameID 的变量>};

判断指定名称的 NPC 是否存在, 就算 NPC 不存在控制台也不会报错
不过用法错误的话还是一样会报错的, 比如: 第二个参数传递了一个字符串变量

NPC名称:
	想要确认的 NPC 名称, 需要使用 NPC 的唯一名称 (::name)
	技巧: 写脚本之前可以使用 strnpcinfo 类型 3 来查询当前 NPC 的唯一名称.
	就是名字最长, 且全服唯一的那个 NPC 名称就是了.

用于保存 GameID 的变量:
	有时候当你确认某个 NPC 存在后, 可能希望对此单位进行其他操作
	那么可以传递一个"数值型"的变量, 如果目标单位存在, 那么程序将自动填充 GameID 返回
	如果目标单位不存在, 那么指定的变量内容将会被设置为 0

返回值:
	存在返回 1, 不存在返回 0

--------------------------------------------------------------

*storagegetitem <物品编号>,<数量>{,<账号编号>};
*storagegetitem "<物品名称>",<数量>{,<账号编号>};

该指令能够直接往个人仓库创建指定的道具.
在个人仓库处于关闭状态的时候才能使用该指令来创建道具.
若仓库已满且创建的道具可被丢在地上, 那么道具将会被丢在角色附近的地面上.

物品编号/名称:
	想要创建到仓库的物品编号, 或者物品名称.

数量:
	想要创建的道具数量, 若是不可堆叠的道具, 则会被创建多个.

账号编号:
	可选参数, 若指定了对应的账号编号, 则操作的是指定账号的仓库.
	若不提供此参数则关联当前调用该指令的玩家.

注意事项:
	密集调用该指令时(比如写个循环调用几百次), 调用者玩家可能会卡一下.
	
	为了降低性能影响, 执行该指令后不会立刻强制服务器保存仓库内容.
	需要等待下一次自动保存数据时, 才会将最新的仓库数据发给角色服务器保存.

返回值:
	添加成功则返回 0, 若失败则返回小于 0 的错误代码:

	-1	-	指定的物品不存在
	-2	-	指定的物品数量不合法 (比如给了个负数)
	-3	-	None
	-4	-	没有关联到玩家, 因此无法找到对应的个人仓库
	-5	-	当前仓库处于打开状态, 需要先关闭仓库才能继续使用
	-6	-	指定的道具不能存放到仓库
	-7	-	本指令暂时不支持创建宠物蛋道具
	-8	-	您没有权限往个人仓库存储道具 (基本不可能发生)
	-9	-	道具放入仓库时失败了, 并且该道具也不是可丢弃到地面的道具

--------------------------------------------------------------

*getcharmac <账户编号>/<角色编号>/<"角色名称">;

与 getcharip 类似, 该指令用于获取玩家登录时客户端网卡的 MAC 地址
但必须要求客户端使用 SSO 方式进行登录才会有记录

注意事项:
	如果无法读取到 MAC 地址, 那么请先确保客户端使用 SSO 方式登录
	如果成功读取到 MAC 地址, 格式应为: "00-00-00-00-00-00"

使用建议:
	哪怕读取到的返回值不是空字符串, 也应判断是否等于 "00-00-00-00-00-00"
	如果等于 "00-00-00-00-00-00" 也可以认为是没读取到

返回值:
	成功则返回 MAC 地址, 读取不到则返回空字符串

--------------------------------------------------------------

*getconstant <"常量字符串">;

查询一个常量字符串对应的数值. 当你仅知道一个常量字符串, 
且试图将它转换成数值参数传递给其他函数时使用

返回值:
	成功则返回常量对应的数值, 查询失败则返回 -255

--------------------------------------------------------------

*preg_search <"字符串">,<"匹配表达式">,<拓展标记位>,<存放匹配结果的字符串数组>;

执行一个正则表达式搜索并返回首个匹配的分组内容

字符串:
	待匹配的字符串, 正则表达式将从中搜索你需要的信息

匹配表达式:
	正则匹配表达式 (pattern), 程序将根据该表达式提取分组内容

拓展标记位:
	掩码选项, 目前可选的只有一个值:
	
	1	-	匹配时忽略大小写

存放匹配结果的字符串数组:
	填写用于返回分组结果的字符串数组名称(无需中括号)

返回值:
	返回负数表示错误, 其他正整数表示匹配到的分组个数 (其中 0 通常不应该出现, 出现也可以当错误)

注意事项:
	读取数组内容时, 请不要使用 getarraysize 去探测数组的长度.
	因为实际匹配过程中, 如果刚好匹配结果的末尾分组内容为空字符串,
	那么 getarraysize 读取数组长度的时候, 它会将空字符串元素忽略, 导致无法获取正确的数组长度.
	
	如果需要遍历, 则应该使用函数的返回值来作为数组内容的长度.

示例代码:
	prontera,150,150,5	script	正则搜索测试	123,{
		// 目标: 提取其中的 HAT_EF_FLUTTER_BUTTERFLY 常量 (左右故意加空格)
		.@text$ = "  hateffect HAT_EF_FLUTTER_BUTTERFLY,true; ";
		
		// 下面是提取用的正则表达式
		// 正则表达式学习成本较高, 一旦掌握, 处理字符串将会达到一个全新的高度
		.@patt$ = ".*?(hateffect(\s{1,}|\()(\(|)\s*(.*?)\s*,\s*(.*?)\s*(|\))(\s*|);)";
		
		// 准备个字符串数组用来存返回的内容 (可以不用特意 setarray, 只是为了示例)
		setarray .@groups$[0],"";
		
		// 注意: 字符串数组名应该以 $ 结尾, 实际传递给 preg_search 时无需携带中括号
		.@match = preg_search(.@text$, .@patt$, 1, .@groups$);
		
		if (.@match <= 0) {
			dispbottom "很抱歉, 匹配失败了...";
			end;
		}
		
		// 循环遍历输出一下匹配到的内容, 若无意外第 5 个元素 (索引 4) 就是我们要的内容
		for (.@i = 0; .@i < .@match; .@i++) {
			dispbottom ".@groups$[" + .@i + "] = " + .@groups$[.@i];
		}
		
		end;
	}

--------------------------------------------------------------

*aura <光环编号>{,<角色编号>};

使角色可以激活指定的光环特效.
光环本质是一组 Effect 效果的组合, 光环编号定义在 db/aura_db.yml 文件中.

光环编号:
	若光环编号为 0 则表示取消光环

返回值:
	成功返回 1, 失败返回 0

使用建议:
	若想知道当前角色使用的光环编号, 直接访问 PANDAS_AURASET 角色变量即可

注意事项:
	在客户端封包版本小于 20181002 的情况下, 获取/失去光环的玩家单位客户端
	会黑屏一下以便刷新光环效果. 为获取最佳的光环效果, 建议使用客户端封包
	版本大于等于 20181002 的客户端.

--------------------------------------------------------------

*unitaura <游戏单位编号>,<光环编号>;

使指定的单位可以激活指定的光环特效.
光环本质是一组 Effect 效果的组合, 光环编号定义在 db/aura_db.yml 文件中.

若你已经知道某个玩家/魔物/佣兵/宠物/NPC/精灵/人工生命体的 <游戏单位编号>,
那么也可以为他们套上一个光环 (但只有玩家的光环会记录在数据库中, 并且会在
重启地图服务器后还能被恢复光环, 其他的几种单位他们的光环会持续生效到地图
服务器退出为止)

游戏单位编号:
	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>	

光环编号:
	若光环编号为 0 则表示取消光环

返回值:
	成功返回 1, 失败返回 0

注意事项:
	在客户端封包版本小于 20181002 的情况下, 获取/失去光环的玩家单位客户端
	会黑屏一下以便刷新光环效果. 为获取最佳的光环效果, 建议使用客户端封包
	版本大于等于 20181002 的客户端.

--------------------------------------------------------------

*getunitdata <游戏单位编号>,<用于保存返回数据的数组名称>;
*setunitdata <游戏单位编号>,<参数>,<新的值>;

在原先 rAthena 官方返回的信息基础上, <参数>和<返回的数组>中新增了以下索引:

	UMOB_AURA - 读取或设置魔物的光环编号
	UHOM_AURA - 读取或设置生命体的光环编号
	UPET_AURA - 读取或设置宠物的光环编号
	UMER_AURA - 读取或设置佣兵的光环编号
	UELE_AURA - 读取或设置精灵的光环编号
	UNPC_AURA - 读取或设置NPC 的光环编号
	
	UMOB_DAMAGETAKEN - 读取或设置指定魔物的承伤倍率
		若值为 -1 则表示直接使用魔物在 db 中设置的默认承伤倍率
		设为 100 则表示魔物受到的伤害是 100%
		设为 80 则表示玩家给魔物造成的伤害只会发挥 80% 的伤害量
		设为 120 则表示玩家给魔物造成的伤害将发挥 120% 的伤害量
		取值范围: 从 -1 到 65535
	UMOB_DAMAGETAKEN_DB - 读取指定魔物在 db 中设置的默认承伤倍率
		注意: 该参数不能用于 setunitdata 指令
	
	UMOB_MOBBASEEXP - 读取或设置魔物的基础经验值
		若值为 -1 则表示直接使用魔物在 db 中设置的默认基础经验值
		取值范围: 从 -1 到 (2^63 - 1)
		注意: 此经验值在最终给玩家的时候会经历各种加成计算, 比如: 经验倍增书、VIP 会员加成等
	UMOB_MOBBASEEXP_DB - 读取指定魔物在 db 中设置的默认基础经验值
		注意: 该参数不能用于 setunitdata 指令

	UMOB_MOBJOBEXP - 读取或设置魔物的职业经验值
		若值为 -1 则表示直接使用魔物在 db 中设置的默认职业经验值
		取值范围: 从 -1 到 (2^63 - 1)
		注意: 此经验值在最终给玩家的时候会经历各种加成计算, 比如: 经验倍增书、VIP 会员加成等
	UMOB_MOBJOBEXP_DB - 读取指定魔物在 db 中设置的默认职业经验值
		注意: 该参数不能用于 setunitdata 指令

--------------------------------------------------------------

*getunittarget <游戏单位编号>;

获取指定单位当前正在攻击的目标单位编号.
支持的单位类型: 玩家/魔物/佣兵/宠物/NPC/精灵/人工生命体

游戏单位编号:
	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>	

返回值:
	返回 0 表示没有攻击目标, 非零则代表: 目标的游戏单位编号

注意事项:
	若给定的游戏单位编号不存在, 返回值也是 0

--------------------------------------------------------------

*unlockcmd;

解锁实时事件和过滤器事件的指令限制, 只能用于实时或过滤器事件

返回值:
	该指令没有任何返回值

提示信息:
	用法和 disable_items; 类似, 直接调用即可 

--------------------------------------------------------------

*batrec_query <记录宿主的单位编号>,<交互目标的单位编号>,<记录类型>{,<聚合规则>};

该指令可以查询指定单位的战斗记录, 确认与交互目标单位产生的具体记录值.

记录宿主的单位编号:
	比如想查询某个魔物的战斗记录, 那就传递此魔物的游戏单位编号

交互目标的单位编号:
	比如想查询玩家对魔物的记录值(或者叫: 伤害值), 则此处传递玩家的游戏单位编号(账号编号)

记录类型:
	BRT_DMG_RECEIVE		- 承伤记录 (记录宿主受到交互目标的伤害记录)
	BRT_DMG_CAUSE		- 输出记录 (记录宿主攻击交互目标的伤害记录)

聚合规则:
	BRA_COMBINE			- 按主人为单位合并查询, 默认值 (宠物/佣兵等拥有主人的生命体, 伤害值计算到主人头上)
	BRA_DISCRETE		- 按独立单位进行查询 (可以单独查询宠物/佣兵对记录宿主的(被)攻击记录)

返回值:
	返回 -1 表示查无记录或发生错误, 含 0 正整数表示伤害值

提示信息:
	若返回的伤害值是 0, 则表示交互单位和宿主之间发生了没有伤害的技能交互 (比如: 缓速术)
	
	每个单位都有自己的战斗记录信息, 单位被销毁之前记录都在.
	记录数上限没有限制, 但越多的记录会开销越多内存.
	
	您可以在 OnUnitKillExpress 单位死亡事件中获取战斗记录的内容以便立即使用它们,
	或者将战斗记录数组保存到其他地方.

--------------------------------------------------------------

*batrec_rank <记录宿主的单位编号>,<返回交互目标的单位编号数组>,<返回记录值数组>,<记录类型>{,<聚合规则>{,<排序规则>}};

查询指定单位的战斗记录并对记录的值进行排序, 返回排行榜单

记录宿主的单位编号:
	比如想查询某个魔物的战斗记录, 那就传递此魔物的游戏单位编号

返回交互目标的单位编号数组:
	指定一个数值型数组, 用于接收按序排列后的游戏单位编号.
	提示: 无论调用成功与否该数组的内容都将被清空
	
	注意: 玩家单位返回的是角色编号而不是游戏单位编号.
	若需获取玩家的游戏单位编号, 建议用: convertpcinfo 指令进行转换.

返回记录值数组:
	指定一个数值型数组, 用于接收与单位编号数组一一对应的记录值.
	提示: 无论调用成功与否该数组的内容都将被清空

记录类型:
	BRT_DMG_RECEIVE		- 承伤记录 (记录宿主受到交互目标的伤害记录)
	BRT_DMG_CAUSE		- 输出记录 (记录宿主攻击交互目标的伤害记录)

聚合规则:
	BRA_COMBINE			- 按主人为单位合并查询, 默认值 (宠物/佣兵等拥有主人的生命体, 伤害值计算到主人头上)
	BRA_DISCRETE		- 按独立单位进行查询 (可以单独查询宠物/佣兵对记录宿主的(被)攻击记录)

排序规则:
	BRS_DESC			- 排行榜按记录值降序排列, 默认值 (记录值越大排名越靠前)
	BRS_ASC				- 排行榜按记录值升序排列 (记录值越小排名越靠前)

返回值:
	失败返回 -1, 含 0 正整数表示数组中返回的榜单记录数

提示信息:
	若返回的伤害值是 0, 则表示交互单位和宿主之间发生了没有伤害的技能交互 (比如: 缓速术)
	
	每个单位都有自己的战斗记录信息, 单位被销毁之前记录都在.
	记录数上限没有限制, 但越多的记录会开销越多内存.
	
	您可以在 OnUnitKillExpress 单位死亡事件中获取战斗记录的内容以便立即使用它们,
	或者将战斗记录数组保存到其他地方.
 
--------------------------------------------------------------

*batrec_sortout <记录宿主的单位编号>{,<记录类型>};

该指令移除指定宿主的战斗记录中, 交互单位已经不存在 (或下线) 的记录

记录宿主的单位编号:
	比如想处理某个魔物的战斗记录, 那就传递此魔物的游戏单位编号

记录类型:
	可选, 不传递此参数则表示处理全部记录
	BRT_DMG_RECEIVE		- 承伤记录 (记录宿主受到交互目标的伤害记录)
	BRT_DMG_CAUSE		- 输出记录 (记录宿主攻击交互目标的伤害记录)

返回值:
	该指令无论成功与否, 都不会有返回值

--------------------------------------------------------------

*batrec_reset <记录宿主的单位编号>;

清除指定单位的战斗记录信息

记录宿主的单位编号:
	比如想清除某个魔物的战斗记录, 那就传递此魔物的游戏单位编号

返回值:
	该指令无论成功与否, 都不会有返回值

--------------------------------------------------------------

*enable_batrec {<游戏单位编号>};
*disable_batrec {<游戏单位编号>};

启用或禁用指定单位的战斗记录.

游戏单位编号:
	可选值, 若不传递则表示控制当前关联到脚本的角色

提示信息:
	您可以通过 batrec_autoenabled_unit 战斗配置选项来控制哪些单位会自动启用战斗记录.

	玩家默认是不会启动战斗记录的, 因此需要使用该指令手动开启.
	玩家角色在开启记录后, 除非玩家下线或者被明确的禁用, 否则将会一直记录.
	
	由于记录本身没上限, 因此玩家在线一直玩, 累计攻击成千上万个魔物的话,
	在调用 batrec_sortout 进行整理之前, 对这些魔物的输出和承伤记录将被长时间保存在内存中.
	
	对于玩家角色来说, 开启战斗记录后若太久忘记关闭会导致地图服务器内存占用持续提高.

返回值:
	该指令无论成功与否, 都不会有返回值

--------------------------------------------------------------

*login <角色编号>{,<默认是否坐下>{,<默认身体朝向>{,<默认脑袋朝向>{,<登录模式>}}}};

将指定的角色以特定的登录模式拉上线

角色编号:
	指定一个想使之上线的角色编号

默认是否坐下:
	0 表示站立, 1 表示坐下
	可选值, 默认值为: 0

	此选项会被 suspend_{afk|normal|offline}_sitdown 战斗配置选项覆盖
	具体被哪个选项影响取决于 <登录模式> 的值

默认身体朝向:
    1 = 西北      0 = 正北      7 = 东北
              ↖     |     ↗
    2 = 正西  <-     +     ->   6 = 正东
              ↙     |     ↘
    3 = 西南      4 = 正南      5 = 东南
	可选值, 默认值为: 4 (正南)
	
	此选项会被 suspend_{afk|normal|offline}_bodydirection 战斗配置选项覆盖
	具体被哪个选项影响取决于 <登录模式> 的值

默认脑袋朝向:
	0 = 相对于身体朝向的正前方, 头部看向正前方
	1 = 相对于身体朝向的正前方, 头部看向右看
	2 = 相对于身体朝向的正前方, 头部看向左看
	可选值, 默认值为: 0 (正前方)
	
	此选项会被 suspend_{afk|normal|offline}_headdirection 战斗配置选项覆盖
	具体被哪个选项影响取决于 <登录模式> 的值

登录模式:
	SUSPEND_MODE_OFFLINE	- 挂机模式
	SUSPEND_MODE_AFK		- 离开模式 (AFK)
	SUSPEND_MODE_NORMAL		- 普通模式
	可选值, 默认值为: SUSPEND_MODE_NORMAL

提示信息:
	请不要在 OnInit / OnInterIfInit / OnInterIfInitOnce 事件中使用该指令,
	因为在触发这几个事件的时候服务器并未就绪.
	
	若必须要在这个时机使用本指令的话, 可以使用 addtimer 将延迟几秒再执行.

返回值:
	成功返回 1, 失败返回 0

--------------------------------------------------------------

*checksuspend {<角色编号|账号编号|"角色名称">};

获取指定角色或指定账号当前在线角色的挂机模式

角色编号|账号编号|"角色名称":
	可选值, 不传递则表示检查当前脚本所关联的角色

返回值:
	-1 						- 表示指定的角色不存在
	SUSPEND_MODE_NONE		- 角色并没有处于任何挂机模式
	SUSPEND_MODE_OFFLINE	- 处于 @suspend 指令带来的离线挂机模式
	SUSPEND_MODE_AFK		- 处于 @afk 指令带来的离开模式
	SUSPEND_MODE_NORMAL		- 处于 login 脚本指令带来的普通挂机模式

提示信息:
	若想检查是否处于离线挂店模式, 可以使用 checkvending 脚本指令

--------------------------------------------------------------

*unitexists <游戏单位编号>{,<单位是否必须存活>};

用来判断指定的游戏单位是否存在.
在 rAthena 的基础上拓展了 <单位是否必须存活> 参数.

游戏单位编号:
	这个编号有不同的叫法: GameID, GID, MapID 等
	每一个游戏中的对象只要会显示在地图上的, 就会有一个自己的 <游戏单位编号>
	游戏玩家进入游戏后, 它的 <账号编号> 就是他角色的 <游戏单位编号>	

单位是否必须存活:
	可选值, 填写 1 表示要求单位必须存活才认为单位存在;
	不填或者填写 0 则认为单位存在就好无需判断是否存活

返回值:
	指定的单位存在则返回 true 否则返回 false

--------------------------------------------------------------

*bonus_script <"效果脚本代码">,<生效时长>{,<标记>{,<类型>{,<状态图标>{,<角色编号>}}}};

在 rAthena 的功能基础上, 熊猫模拟器拓展了它的返回值.
各参数的详细说明请直接参考 doc/script_commands.txt 中 bonus_script 的说明.

返回值:
	执行成功则返回该 bonus_script 实例的唯一编号,
	执行失败, 或者 bonus_script 在没有指定 2048 强制覆盖标记的情况下已存在则返回 0.
	此处的唯一编号可以用于 bonus_script_remove 等拓展指令.

注意事项:
	正常情况下连续执行两次相同的 bonus_script 只有第一次能获得编号, 如:

		// 第一次, .@bonusid 将返回有效的唯一编号
		.@bonusid = bonus_script("{ bonus bStr,5; }",60);
		
		// 第二次, 没有特殊指定强制覆盖标记, 虽然时间会重置, 但返回值将依然是 0
		.@bonusid = bonus_script("{ bonus bStr,5; }",60);

	bonus_script 的 <标记> 允许您设定 2048 来强制重复 bonus_script 脚本, 如:
	
		// 第一次, .@bonusid 将返回有效的唯一编号, 比如: 644245094400002
		.@bonusid = bonus_script("{ bonus bStr,5; }",60,2048);
	
		// 第二次, .@bonusid 也会返回有效的唯一编号, 但将于第一次创建时的编号不同, 比如: 644245094400003
		.@bonusid = bonus_script("{ bonus bStr,5; }",60,2048);
		
		在这种情况下, 两次创建的 bonus_script 将同时生效, 在它们同时生效期间角色的 STR 将会是 +10

--------------------------------------------------------------

*bonus_script_remove <效果脚本编号>{,<角色编号>};

用于移除指定的 bonus_script 效果脚本.

效果脚本编号:
	当时调用 bonus_script 指令成功后, 会返回一个效果脚本编号.
	传入这个编号即可将这个效果脚本移除

返回值:
	成功移除则返回 true, 找不到脚本代码或移除失败则返回 false

--------------------------------------------------------------

*bonus_script_list <返回效果脚本编号的数值型数组>{,<角色编号>};

用于获取指定角色当前激活的全部 bonus_script 效果脚本编号.
效果脚本编号在调用 bonus_script 成功后会返回.

返回效果脚本编号的数值型数组:
	数值类型的数组, 用于接收指定角色当前已被激活的效果脚本编号.
	提示: 无论调用成功与否该数组的内容都将被清空

返回值:
	获取到的效果脚本编号数量, 发生错误则返回 -1

--------------------------------------------------------------

*bonus_script_exists <效果脚本编号>{,<角色编号>};

用于查询指定角色是否已经激活了特定的 bonus_script 效果脚本.

效果脚本编号:
	当时调用 bonus_script 指令成功后, 会返回一个效果脚本编号.
	传入这个编号即可查询该脚本效果是否还存在.

返回值:
	效果存在则返回 true, 角色不在线或效果不存在否则返回 false

--------------------------------------------------------------

*bonus_script_getid <"效果脚本代码">,<返回效果脚本编号数组>{,<角色编号>};

用于查询指定效果脚本代码字符串在指定角色上所对应的效果脚本编号,
若有多个重叠则返回多个效果脚本编号.

效果脚本代码:
	想要查询的效果脚本代码字符串,
	必须和调用 bonus_script 脚本时传入的第一个参数一模一样

返回效果脚本编号数组:
	数值类型的数组, 由于同一个角色身上可以通过 bonus_script 的 2048 标记来创建
	多个重叠的效果脚本, 因此这里可能会返回多个效果脚本编号

返回值:
	查询到的记录数, 若为 -1 表示出错; 若为 0 则表示无记录;
	其他非 0 正整数表示数组中返回的效果脚本编号数量

--------------------------------------------------------------

*bonus_script_info <效果脚本编号>,<查询类型>{,<角色编号>};

用于查询指定效果脚本的相关信息.
只需要提供指定的效果脚本编号, 并且该效果在指定角色身上处于激活状态,
就可以查询到它的相关信息.

效果脚本编号:
	当时调用 bonus_script 指令成功后, 会返回一个效果脚本编号.
	传入这个编号即可查询该脚本效果是否还存在.

查询类型:
	0	-	效果脚本代码, 返回字符串类型的值
	1	-	标记位. 即调用 bonus_script 时传递的 flag 字段值
	2	-	状态图标编号. 即调用 bonus_script 时传递的 status_icon 字段值
	3	-	效果类型. 即调用 bonus_script 时传递的 type 字段值
	4	-	剩余时间 (单位为毫秒)

返回值:
	若指定的角色不存在则返回 -2
	给定的效果脚本编号不存在则返回 -3
	若给定的查询类型不在有效的范围内则返回 -4
	
	其中除查询类型 1 的返回值为字符串外, 其他查询类型的返回值皆为数值型.
	其中查询类型 2 返回 -1 表示没有图标.
	其中查询类型 4 返回 -1 表示该效果脚本永不超时.

--------------------------------------------------------------

*expandinventory_adjust <增加多少容量>;

用于调整角色的背包容量上限.

增加多少容量:
	玩家现在容量是 100 你想把它调整为 115, 那么此处只需要传递 15 即可

返回值:
	调整成功返回 1, 失败返回 0

注意事项:
	背包扩容是 RO 客户端支持的一个功能, 最大可以将角色的背包从 100 扩容到 200.
	客户端则封包版本号必须 >= 20181031 才支持.

--------------------------------------------------------------

*getinventorysize {<角色编号>};

用于查询并获取指定角色的背包容量上限.

返回值:
	找不到角色则返回 0, 否则返回查询到的背包容量

--------------------------------------------------------------

*announce "<消息文本>",<标记位>{,<字体颜色>{,<字体类型>{,<字体大小>{,<字体对齐>{,<字体垂直>{,<角色编号>}}}}}};

在 rAthena 原来的标记位基础上, 熊猫模拟器新增了以下标记位:

标记位:
	bc_name:	在聊天栏中双击此消息时会将发布者角色名称填写到聊天窗口

示例代码:
	announce "双击这条文本可以私聊我哟",bc_all|bc_name;

提示信息:
	若调用 announce 的脚本没有关联到玩家, 那么 bc_name 标记位将会被忽视.
	
	由于客户端限制, 在设置上 bc_name 标记位后, 除了<字体颜色>字段依然有效外, 其他像:
	<字体类型>,<字体大小>,<字体对齐>,<字体垂直> 等字段将被忽视.

注意事项:
	发送者自己双击聊天栏中的公告信息是无效的, 其他玩家可以.
	此功能在 20130807 客户端上测试有效, 更早之前的客户端并未经过测试.

--------------------------------------------------------------

*getmapspawns "<地图名称>"{,<角色编号>};

用于获取指定地图的魔物刷新点信息.

地图名称:
	指定的地图名称, 比如 "prontera" 表示普隆德拉
	地图名称可以设置为 "this", 表示获取当前脚本关联玩家所在的地图

角色编号:
	若指定了角色编号则使用 "this" 地图名称时将会查询指定角色所在地图的魔物刷新点信息
	此外 @ 变量的值也将绑定记录到该角色身上

信息通过变量返回:
	@spawn_mobid[]		魔物编号 - 数值型数组
	@spawn_name$[]		魔物名称 - 字符型数组
						使用 monster 指令的刷怪点可以设置魔物名称,
						因此当若有指定特殊魔物名称则优先返回特殊魔物名称
	@spawn_num[]		刷新魔物数量 - 数值型数组
	@spawn_active[]		魔物当前激活数量 - 数值型数组
						当启用 dynamic_mobs 时, 如果地图没有玩家存在则魔物不会被激活
	@spawn_size[]		魔物体型 - 数值型数组
						若为 -1 表示默认体型, 通常可能的返回值有:
							SZ_SMALL	-	表示小型
							SZ_MEDIUM	-	表示中型
							SZ_BIG		-	表示大型
	@spawn_isboss[]		魔物是否为 BOSS (可被 BOSS 雷达探测) - 数值型数组
							为 0 表示普通魔物, 为 1 表示 BOSS 魔物
	@spawn_delay1[]		魔物死亡后的固定刷新间隔 (单位为毫秒) - 数值型数组
	@spawn_delay2[]		额外的随机浮动刷新间隔 (单位为毫秒) - 数值型数组
							若配置了 delay2 则魔物死亡后的刷新间隔为: delay1 ~ (delay1 + delay2) 之间的随机毫秒数
	@spawn_ai[]			魔物的 AI 模式 - 数值型数组
						若为 -1 表示默认 AI 模式, 通常可能的返回值有:
							AI_NONE
							AI_ATTACK
							AI_SPHERE
							AI_FLORA
							AI_ZANZOU
							AI_LEGION
							AI_FAW
							AI_GUILD
	@spawn_level[]		魔物等级 - 数值型数组
							使用 monster 指令的刷怪点可以设置魔物等级,
							因此当若有指定特殊魔物等级则优先返回特殊魔物等级
	@spawn_eventname$[]	魔物死亡时触发的事件标签 - 字符型数组
							若为空字符串则表示没有指定魔物死亡时触发的事件标签
	@spawn_mapid[]		魔物所在的地图编号 (通常没啥作用) - 数值型数组
	@spawn_mapname$[]	魔物所在的地图名称 - 字符型数组
	@spawn_x[]			魔物刷新点在地图上的 x 坐标 - 数值型数组
	@spawn_y[]			魔物刷新点在地图上的 y 坐标 - 数值型数组
	@spawn_xs[]			魔物刷新点在地图上的 xs 坐标 (若为 -1 则表示没有指定) - 数值型数组
	@spawn_ys[]			魔物刷新点在地图上的 ys 坐标 (若为 -1 则表示没有指定) - 数值型数组


	返回值及 @spawn_count 变量都会赋予查询到的魔物刷怪点数量.

返回值:
	成功则返回找到的刷新点数量, 失败则返回 -1

注意事项:
	返回值数组变量是 @ 开头的角色变量.
	若指令在不关联任何玩家的情况下被执行之后, 可以改用 $@ 变量来承接返回值.
	
	若您使用 $@ 变量来承接返回值内容的话,
	调用 getmapspawns 之后应该立刻使用变量的内容, 因为 $@ 变量是全服共享的, 
	如果调用完成后不立刻使用, 可能里面填充的内容就被其他玩家调用 getmapspawns 替换掉了.
	
	当使用 "this" 指令的时候, 若脚本不关联任何玩家的话, 那么必须指定 <角色编号>,
	否则地图服务器将无法理解 "this" 具体是哪一张地图.
	
	如果您希望列出一些菜单项让玩家做选择的话, 请使用 @ 变量承接.
	因为 @ 变量只保存在玩家角色身上, 不会被服务器其他玩家调用 getmapspawns 指令而覆盖.
	
	与 getinventorylist 指令一样, 请避免使用 getarraysize 来计算返回数组的长度,
	而是使用 @spawn_count 来作为返回数组中有效内容的最大数量, 否则可能会读取到部分垃圾数据.

--------------------------------------------------------------

*getmobspawns <魔物编号>{,"<地图名称>"{,<角色编号>}};

用于查询指定魔物在不同地图的刷新点信息.

魔物编号:
	想查询哪个魔物的刷新点信息, 就填写该魔物的编号

地图名称:
	指定的地图名称, 比如 "prontera" 表示普隆德拉
	地图名称可以设置为 "this", 表示获取当前脚本关联玩家所在的地图

角色编号:
	若指定了角色编号则使用 "this" 地图名称时将会查询指定角色所在地图的魔物刷新点信息
	此外 @ 变量的值也将绑定记录到该角色身上

信息通过变量返回:
	@spawn_mobid[]		魔物编号 - 数值型数组
	@spawn_name$[]		魔物名称 - 字符型数组
						使用 monster 指令的刷怪点可以设置魔物名称,
						因此当若有指定特殊魔物名称则优先返回特殊魔物名称
	@spawn_num[]		刷新魔物数量 - 数值型数组
	@spawn_active[]		魔物当前激活数量 - 数值型数组
						当启用 dynamic_mobs 时, 如果地图没有玩家存在则魔物不会被激活
	@spawn_size[]		魔物体型 - 数值型数组
						若为 -1 表示默认体型, 通常可能的返回值有:
							SZ_SMALL	-	表示小型
							SZ_MEDIUM	-	表示中型
							SZ_BIG		-	表示大型
	@spawn_isboss[]		魔物是否为 BOSS (可被 BOSS 雷达探测) - 数值型数组
							为 0 表示普通魔物, 为 1 表示 BOSS 魔物
	@spawn_delay1[]		魔物死亡后的固定刷新间隔 (单位为毫秒) - 数值型数组
	@spawn_delay2[]		额外的随机浮动刷新间隔 (单位为毫秒) - 数值型数组
							若配置了 delay2 则魔物死亡后的刷新间隔为: delay1 ~ (delay1 + delay2) 之间的随机毫秒数
	@spawn_ai[]			魔物的 AI 模式 - 数值型数组
						若为 -1 表示默认 AI 模式, 通常可能的返回值有:
							AI_NONE
							AI_ATTACK
							AI_SPHERE
							AI_FLORA
							AI_ZANZOU
							AI_LEGION
							AI_FAW
							AI_GUILD
	@spawn_level[]		魔物等级 - 数值型数组
							使用 monster 指令的刷怪点可以设置魔物等级,
							因此当若有指定特殊魔物等级则优先返回特殊魔物等级
	@spawn_eventname$[]	魔物死亡时触发的事件标签 - 字符型数组
							若为空字符串则表示没有指定魔物死亡时触发的事件标签
	@spawn_mapid[]		魔物所在的地图编号 (通常没啥作用) - 数值型数组
	@spawn_mapname$[]	魔物所在的地图名称 - 字符型数组
	@spawn_x[]			魔物刷新点在地图上的 x 坐标 - 数值型数组
	@spawn_y[]			魔物刷新点在地图上的 y 坐标 - 数值型数组
	@spawn_xs[]			魔物刷新点在地图上的 xs 坐标 (若为 -1 则表示没有指定) - 数值型数组
	@spawn_ys[]			魔物刷新点在地图上的 ys 坐标 (若为 -1 则表示没有指定) - 数值型数组


	返回值及 @spawn_count 变量都会赋予查询到的魔物刷怪点数量.

返回值:
	成功则返回找到的刷新点数量, 失败则返回 -1

注意事项:
	返回值数组变量是 @ 开头的角色变量.
	若指令在不关联任何玩家的情况下被执行之后, 可以改用 $@ 变量来承接返回值.
	
	若您使用 $@ 变量来承接返回值内容的话,
	调用 getmobspawns 之后应该立刻使用变量的内容, 因为 $@ 变量是全服共享的, 
	如果调用完成后不立刻使用, 可能里面填充的内容就被其他玩家调用 getmobspawns 替换掉了.
	
	当使用 "this" 指令的时候, 若脚本不关联任何玩家的话, 那么必须指定 <角色编号>,
	否则地图服务器将无法理解 "this" 具体是哪一张地图.
	
	如果您希望列出一些菜单项让玩家做选择的话, 请使用 @ 变量承接.
	因为 @ 变量只保存在玩家角色身上, 不会被服务器其他玩家调用 getmobspawns 指令而覆盖.

--------------------------------------------------------------

*getcalendartime <小时>,<分钟>{,<月的第几天>{,<周的第几天>}};

获取下次出现指定时间的 UNIX 时间戳

小时:
	可填写值为 0 ~ 23 代表 24 小时

分钟:
	可填写值为 0 ~ 59 代表 60 分钟

月的第几天:
	可填写值为 1 ~ 31 代表 31 天; 填写 -1 则表示与月份无关

周的第几天:
	SUNDAY - 周日
	MONDAY - 周一
	TUESDAY - 周二
	WEDNESDAY - 周三
	THURSDAY - 周四
	FRIDAY - 周五
	SATURDAY - 周六

如果只想使用 <每周的第几天> 而不想使用 <每月的第几天>,
那么将 <每月的第几天> 设为 -1 即可

返回值:
	成功则返回时间戳, 失败则返回 -1

示例代码:
	getcalendartime(19, 00); 				// 获取下次 19:00 的时间戳
	getcalendartime(19, 00, 6); 			// 获取下次 6 号 19:00 的时间戳
	getcalendartime(19, 10, -1, MONDAY);	// 获取下次 周一 19:10 的时间戳

--------------------------------------------------------------

*getskillinfo <查询的信息类型>,<技能编号>{,<技能等级>{,<角色编号>}};
*getskillinfo <查询的信息类型>,<"技能名称">{,<技能等级>{,<角色编号>}};

获取指定技能在技能数据库中所配置的各项信息

查询的信息类型:
	SKI_CASTTYPE
		技能施法类型
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中提供的 TargetType 进行计算得出
		
		可能的返回值:
		----------------
		CAST_GROUND				/// 地面技能
		CAST_DAMAGE				/// 伤害技能
		CAST_NODAMAGE			/// 无伤害技能
		
	SKI_NAME
		技能名称
		
		返回值为字符串类型
		该字段的值来自 skill_db.yml 中的 Name 字段
		通常技能名称是英文常量, 比如狂击的技能名称是 SM_BASH
		
	SKI_DESCRIPTION
		技能描述
		
		返回值为字符串类型
		该字段的值来自 skill_db.yml 中的 Description 字段
		通常技能描述是游戏里的技能名称, 比如: 狂击
		
	SKI_MAXLEVEL_IN_SKILLTREE
		指定职业的技能树中该技能的最大等级
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入要查询的职业代码
		该字段的值来自 skill_tree.txt 中不同职业对被查询技能所设置的最大技能等级
		
	SKI_SKILLTYPE
		技能伤害类型
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Type 字段
		
		可能的返回值:
		----------------
		BF_WEAPON				/// 物理攻击类型
		BF_MAGIC				/// 魔法攻击类型
		BF_MISC					/// 其他类型
		
	SKI_HIT
		技能命中类型
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Hit 字段
		
		可能的返回值:
		----------------
		DMG_SINGLE				/// (skill?)
		DMG_MULTI_HIT			/// multi-hit damage
		
	SKI_TARGETTYPE
		技能目标类型
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 TargetType 字段
		
		可能的返回值:
		----------------
		INF_PASSIVE_SKILL		/// 
		INF_ATTACK_SKILL		/// 
		INF_GROUND_SKILL		/// 
		INF_SELF_SKILL			/// 
		INF_SUPPORT_SKILL		///
		INF_TRAP_SKILL			///
		
	SKI_ELEMENT
		技能属性
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Element 字段
		
		可能的返回值:
		----------------
		ELE_NEUTRAL				/// 无属性 / 自然属性
		ELE_WATER				/// 水属性
		ELE_EARTH				/// 地属性
		ELE_FIRE				/// 火属性
		ELE_WIND				/// 风属性
		ELE_POISON				/// 毒属性
		ELE_HOLY				/// 圣属性
		ELE_DARK				/// 暗属性
		ELE_GHOST				/// 幽灵属性
		ELE_UNDEAD				/// 不死属性
		ELE_WEAPON				/// 使用武器的属性
		ELE_ENDOWED				/// ??? 谁有了解的翻译一下
		ELE_RANDOM				/// 随机属性
		
	SKI_DAMAGEFLAGS
		技能伤害的修正标记
		
		返回值为数值类型, 返回的是数组长度
		用于承接返回值的数组名称为: @skill_damage_flags[]
		若在不关联任何玩家的情况下执行, 则用于承接返回值的数组名称为: $@skill_damage_flags[]
		该字段的值来自 skill_db.yml 中的 DamageFlags 字段
		
		返回值数组中保存是该技能激活的伤害修正标记
		
		可能的返回值:
		----------------
		NK_NODAMAGE				/// 对应 DamageFlags 的 NoDamage 字段
		NK_SPLASH				/// 对应 DamageFlags 的 Splash 字段
		NK_SPLASHSPLIT			/// 对应 DamageFlags 的 SplashSplit 字段
		NK_IGNOREATKCARD		/// 对应 DamageFlags 的 IgnoreAtkCard 字段
		NK_IGNOREELEMENT		/// 对应 DamageFlags 的 IgnoreElement 字段
		NK_IGNOREDEFENSE		/// 对应 DamageFlags 的 IgnoreDefense 字段
		NK_IGNOREFLEE			/// 对应 DamageFlags 的 IgnoreFlee 字段
		NK_IGNOREDEFCARD		/// 对应 DamageFlags 的 IgnoreDefCard 字段
		NK_CRITICAL				/// 对应 DamageFlags 的 Critical 字段
		NK_IGNORELONGCARD		/// 对应 DamageFlags 的 IgnoreLongCard 字段
		
		例子:
		----------------
		以下示例代码是在 v1.2.4 版本调整后的最新用法
		
		getskillinfo SKI_DAMAGEFLAGS,"PR_ASPERSIO";
		
		if (@skill_damage_flags[NK_SPLASH]) {
			dispbottom "此技能拥有 Splash 伤害标志位"; // PR_ASPERSIO 没有这个标记位, 不会输出这一行
		}
		if (@skill_damage_flags[NK_IGNOREELEMENT]) {
			dispbottom "此技能拥有 IgnoreElement 伤害标志位";
		}
		
	SKI_MAXLEVEL
		技能最大等级
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 MaxLevel 字段
		
	SKI_RANGE
		技能有效范围 / 攻击距离
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Range 字段
		
	SKI_SPLASHAREA
		技能溅射范围
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 SplashArea 字段
		
	SKI_HITCOUNT
		技能打击段数
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 HitCount 字段
		
	SKI_CASTTIME
		技能可变咏唱时间 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 CastTime 字段
		
	SKI_FIXEDCASTTIME
		技能固定咏唱时间 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 FixedCastTime 字段
		
		仅复兴后版本中拥有固定咏唱时间这个设定, 复兴前版本中该类查询返回值强制为 -1
		
	SKI_AFTERCASTACTDELAY
		技能咏唱完毕后的动作延迟时间, 别名: 技能公共延迟 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 AfterCastActDelay 字段
		
	SKI_AFTERCASTWALKDELAY
		技能咏唱完毕后的移动僵直时间, 别名: 技能攻击僵直 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 AfterCastWalkDelay 字段
		
	SKI_DURATION1
		技能时间配置字段 1 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Duration1 字段
		
		不同的技能对该字段的使用方式不同, 因此没有明确的作用说明
		例如: 复兴后的 SM_ENDURE 技能在 Duration1 中配置的值被用作 "霸体" 的效果时长
		
	SKI_DURATION2
		技能时间配置字段 2 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Duration2 字段
		
		不同的技能对该字段的使用方式不同, 因此没有明确的作用说明
		例如: 复兴后的 PR_LEXDIVINA 技能在 Duration2 中配置的值被用作 "沉默之术" 的效果时长
		
	SKI_CASTTIMEFLAGS
		技能咏唱时间的修正标记
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 CastTimeFlags 字段
		
		可能的返回值:
		----------------
		SKILL_CAST_IGNOREDEX		/// 标记位, 无视 DEX 带来的修正影响
		SKILL_CAST_IGNORESTATUS		/// 标记位, 无视角色状态 (StatusChange / 简称 SC) 的修正影响
		SKILL_CAST_IGNOREITEMBONUS	/// 标记位, 无视 bonus 效果调整器的修正影响
		
	SKI_CASTDELAYFLAGS
		技能延迟时间的修正标记
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 CastDelayFlags 字段
		
		可能的返回值:
		----------------
		SKILL_CAST_IGNOREDEX		/// 标记位, 无视 DEX 带来的修正影响
		SKILL_CAST_IGNORESTATUS		/// 标记位, 无视角色状态 (StatusChange / 简称 SC) 的修正影响
		SKILL_CAST_IGNOREITEMBONUS	/// 标记位, 无视 bonus 效果调整器的修正影响
		
	SKI_CASTDEFENSEREDUCTION
		技能在咏唱期间造成施法者的防御降低倍率
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 CastDefenseReduction 字段
		
	SKI_FLAGS
		技能特殊标记
		
		返回值为数值类型, 返回的是数组长度
		用于承接返回值的数组名称为: @skill_flags[]
		若在不关联任何玩家的情况下执行, 则用于承接返回值的数组名称为: $@skill_flags[]
		该字段的值来自 skill_db.yml 中的 Flags 字段
		
		返回值数组中保存是该技能的特殊标记
		
		可能的返回值:
		----------------
		INF2_ISQUEST				/// 这是任务技能
		INF2_ISNPC					/// 
		INF2_ISWEDDING				/// 这是结婚后才能拥有的技能
		INF2_ISSPIRIT				/// 
		INF2_ISGUILD				/// 这是公会技能
		INF2_ISSONG					/// 
		INF2_ISENSEMBLE				/// 
		INF2_ISTRAP					/// 这是陷阱技能
		INF2_TARGETSELF				/// 
		INF2_NOTARGETSELF			/// 
		INF2_PARTYONLY				/// 只能对队伍中的成员使用
		INF2_GUILDONLY				/// 只能对公会中的成员使用
		INF2_NOTARGETENEMY			/// 
		INF2_ISAUTOSHADOWSPELL		/// 
		INF2_ISCHORUS				/// 
		INF2_IGNOREBGREDUCTION		/// 
		INF2_IGNOREGVGREDUCTION		/// 
		INF2_DISABLENEARNPC			/// 靠近部分 NPC 时禁止使用此技能
		INF2_TARGETTRAP				/// 
		INF2_IGNORELANDPROTECTOR	/// 
		INF2_ALLOWWHENHIDDEN		/// 
		INF2_ALLOWWHENPERFORMING	/// 
		INF2_TARGETEMPERIUM			/// 
		INF2_IGNOREKAGEHUMI			/// 
		INF2_ALTERRANGEVULTURE		/// 
		INF2_ALTERRANGESNAKEEYE		/// 
		INF2_ALTERRANGESHADOWJUMP	/// 
		INF2_ALTERRANGERADIUS		/// 
		INF2_ALTERRANGERESEARCHTRAP	/// 
		INF2_IGNOREHOVERING			/// 
		INF2_ALLOWONWARG			/// 
		INF2_ALLOWONMADO			/// 
		INF2_TARGETMANHOLE			/// 
		INF2_TARGETHIDDEN			/// 
		INF2_INCREASEDANCEWITHWUGDAMAGE		/// 
		INF2_IGNOREWUGBITE			/// 
		INF2_IGNOREAUTOGUARD		/// 
		INF2_IGNORECICADA			/// 
		INF2_SHOWSCALE				/// 
		
		例子:
		----------------
		以下示例代码是在 v1.2.4 版本调整后的最新用法
		
		getskillinfo SKI_FLAGS,"CR_DEVOTION";
		
		if (@skill_flags[INF2_NOTARGETSELF]) {
			dispbottom "此技能拥有 NoTargetSelf 标志位";
		}
		
	SKI_CASTCANCEL
		技能在咏唱期间是否会被打断
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 CastCancel 字段
		
	SKI_ACTIVEINSTANCE
		技能同时存在的个数上限, 通常作用于地面技能
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 ActiveInstance 字段
		
	SKI_KNOCKBACK
		技能击退距离
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Knockback 字段
		
	SKI_COOLDOWN
		技能可以被再次使用的冷却时间 (单位为毫秒)
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Cooldown 字段
		
	SKI_NONEARNPC_TYPE
		技能不可在哪些 NPC 附近使用
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 NoNearNPC 节点的 Type 字段
		
		该选项的两种情况生效:
			当 Flags 中设定了 DisableNearNpc 时生效
			当 Unit->Flag 中设定了 NoFootSet 时生效
		
		可能的返回值:
		----------------
		SKILL_NONEAR_WARPPORTAL		/// 标记位, 不能靠近传送点附近
		SKILL_NONEAR_SHOP			/// 标记位, 不能靠近商店附近
		SKILL_NONEAR_NPC			/// 标记位, 不能靠近 NPC 附近
		SKILL_NONEAR_TOMB			/// 标记位, 不能靠近 MVP 坟墓附近
		
	SKI_NONEARNPC_ADDITIONALRANGE
		技能不可靠近的 NPC 额外距离要求
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 NoNearNPC 节点的 AdditionalRange 字段
		
	SKI_COPYFLAGS_SKILL
		技能是否能被复制
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 CopyFlags 节点的 Skill 字段
		
		可能的返回值:
		----------------
		0							/// 不可被复制
		SKILL_COPY_PLAGIARISM		/// 标记位, 可以被"抄袭"技能 (RG_PLAGIARISM) 复制
		SKILL_COPY_REPRODUCE		/// 标记位, 可以被"复制"技能 (SC_REPRODUCE) 复制
		
	SKI_COPYFLAGS_REMOVEREQUIREMENT
		技能被复制后, 抄袭者进行施法时是否忽略部分条件
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 CopyFlags 节点的 RemoveRequirement 字段
		
		可能的返回值:
		----------------
		SKILL_REQ_HPCOST			/// 标记位, 无需扣减指定点数的 HP
		SKILL_REQ_SPCOST			/// 标记位, 无需扣减指定点数的 SP
		SKILL_REQ_HPRATECOST		/// 标记位, 无需扣减指定百分比的 HP
		SKILL_REQ_SPRATECOST		/// 标记位, 无需扣减指定百分比的 SP
		SKILL_REQ_MAXHPTRIGGER		/// 标记位, 无需检查至少要有百分之多少 HP 才能施法
		SKILL_REQ_ZENYCOST			/// 标记位, 无需扣减指定数量的 Zeny
		SKILL_REQ_WEAPON			/// 标记位, 无需检查武器符合特定类型
		SKILL_REQ_AMMO				/// 标记位, 无需检查弹药符合特定类型
		SKILL_REQ_STATE				/// 标记位, 无需检查场景类型
		SKILL_REQ_STATUS			/// 标记位, 无需检查角色状态类型
		SKILL_REQ_SPIRITSPHERECOST	/// 标记位, 无需检查灵气弹数量
		SKILL_REQ_ITEMCOST			/// 标记位, 无需检查特定物品消耗品
		SKILL_REQ_EQUIPMENT			/// 标记位, 无需检查是否穿戴特定装备
		
	SKI_UNIT_ID
		技能绑定的首选 Unit 子单位编号
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Unit 节点的 Id 字段
		
	SKI_UNIT_ALTERNATEID
		技能绑定的备选 Unit 子单位编号
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Unit 节点的 AlternateId 字段
		
	SKI_UNIT_LAYOUT
		技能绑定的 Unit 子单位布局
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Unit 节点的 Layout 字段
		
	SKI_UNIT_RANGE
		技能绑定的 Unit 子单位作用距离
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Unit 节点的 Range 字段
		
	SKI_UNIT_INTERVAL
		技能绑定的 Unit 子单位间隔时间 (单位为毫秒)
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Unit 节点的 Interval 字段
		
	SKI_UNIT_TARGET
		技能绑定的 Unit 子单位作用目标
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Unit 节点的 Target 字段
		
		可能的返回值:
		----------------
		BCT_SELF					/// 自己
		BCT_ENEMY					/// 敌人
		BCT_PARTY					/// 队伍成员
		BCT_GUILDALLY				/// 同盟成员, 不含公会成员
		BCT_NEUTRAL					/// 自然目标
		BCT_SAMEGUILD				/// 公会成员, 不含同盟成员
		
	SKI_UNIT_FLAG
		技能绑定的 Unit 子单位特殊标记
		
		返回值为数值类型, 返回的是数组长度
		用于承接返回值的数组名称为: @skill_unit_flag[]
		若在不关联任何玩家的情况下执行, 则用于承接返回值的数组名称为: $@skill_unit_flag[]
		该字段的值来自 skill_db.yml 中的 Unit 节点的 Flag 字段
		
		可能的返回值:
		----------------
		UF_NOENEMY					/// If 'defunit_not_enemy' is set, the target is changed to 'friend'
		UF_NOREITERATION			/// Spell cannot be stacked
		UF_NOFOOTSET				/// Spell cannot be cast near/on targets
		UF_NOOVERLAP				/// Spell effects do not overlap
		UF_PATHCHECK				/// Only cells with a shootable path will be placed
		UF_NOPC						/// May not target players
		UF_NOMOB					/// May not target mobs
		UF_SKILL					/// May target skills
		UF_DANCE					/// Dance
		UF_ENSEMBLE					/// Duet
		UF_SONG						/// Song
		UF_DUALMODE					/// Spells should trigger both ontimer and onplace/onout/onleft effects.
		UF_NOKNOCKBACK				/// Skill unit cannot be knocked back
		UF_RANGEDSINGLEUNIT			/// hack for ranged layout, only display center
		UF_CRAZYWEEDIMMUNE			/// Immune to Crazy Weed removal
		UF_REMOVEDBYFIRERAIN		/// removed by Fire Rain
		UF_KNOCKBACKGROUP			/// knockback skill unit with its group instead of single unit
		UF_HIDDENTRAP				/// Hidden trap [Cydh]
		
		例子:
		----------------
		以下示例代码是在 v1.2.4 版本调整后的最新用法
		
		getskillinfo SKI_UNIT_FLAG,"RA_MAGENTATRAP";
		
		if (@skill_unit_flag[UF_NOPC]) {
			dispbottom "此技能拥有 NoPc 伤害标志位";
		}
		
	SKI_REQUIRES_HPCOST
		技能施法条件 - 需要扣减多少点 HP 才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 HpCost 字段
		
	SKI_REQUIRES_SPCOST
		技能施法条件 - 需要扣减多少点 SP 才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 SpCost 字段
		
	SKI_REQUIRES_MAXHPTRIGGER
		技能施法条件 - 需要至少剩余百分之多少的 HP 才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 MaxHpTrigger 字段
		
	SKI_REQUIRES_HPRATECOST
		技能施法条件 - 需要扣减百分之多少的 HP 才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 HpRateCost 字段
		
	SKI_REQUIRES_SPRATECOST
		技能施法条件 - 需要扣减百分之多少的 SP 才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 SpRateCost 字段
		
	SKI_REQUIRES_ZENYCOST
		技能施法条件 - 需要扣减多少 Zeny 才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 ZenyCost 字段
		
	SKI_REQUIRES_WEAPON
		技能施法条件 - 至少需要装备符合任意一个类型的武器才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 Weapon 字段
		
		可能的返回值:
		----------------
		0							/// 任何武器
		W_DAGGER					/// 短剑
		W_1HSWORD					/// 单手剑
		W_2HSWORD					/// 双手剑
		W_1HSPEAR					/// 单手矛/枪/戟
		W_2HSPEAR					/// 双手矛/枪/戟
		W_1HAXE						/// 单手斧
		W_2HAXE						/// 双手斧
		W_MACE						/// 单手钝器
		W_2HMACE					/// 双手钝器
		W_STAFF						/// 单手杖
		W_2HSTAFF					/// 双手杖
		W_BOW						/// 弓
		W_KNUCKLE					/// 拳套
		W_MUSICAL					/// 乐器
		W_WHIP						/// 鞭子
		W_BOOK						/// 书
		W_KATAR						/// 拳刃
		W_REVOLVER					/// 左轮手枪
		W_RIFLE						/// 来复枪
		W_GATLING					/// 格林机关枪
		W_SHOTGUN					/// 散弹枪
		W_GRENADE					/// 榴弹枪
		W_HUUMA						/// 风魔
		MAX_WEAPON_TYPE				/// 该值减去 1 等于最大的武器类型值 (遍历用)
		
		例子:
		----------------
		(返回值 & (1 << W_DAGGER)) == (1 << W_DAGGER) 成立则表示穿戴短剑才能施法
		
	SKI_REQUIRES_AMMO
		技能施法条件 - 需要装备哪种类型的弹药才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 Ammo 字段
		
		可能的返回值:
		----------------
		0							/// 任何弹药
		AMMO_ARROW					/// 箭矢
		AMMO_DAGGER					/// 短刀
		AMMO_BULLET					/// 子弹
		AMMO_SHELL					/// 炮弹
		AMMO_GRENADE				/// 榴弹
		AMMO_SHURIKEN				/// 手里剑
		AMMO_KUNAI					/// 苦无
		AMMO_CANNONBALL				/// 加农炮弹
		AMMO_THROWWEAPON			/// 投掷物品
		MAX_AMMO_TYPE				/// 该值减去 1 等于最大的弹药类型值 (遍历用)
		
		例子:
		----------------
		(返回值 & (1 << AMMO_ARROW)) == (1 << AMMO_ARROW) 成立则表示使用箭矢作为弹药才能施法
		
	SKI_REQUIRES_AMMOAMOUNT
		技能施法条件 - 需要多少个指定的弹药才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 AmmoAmount 字段
		
	SKI_REQUIRES_STATE
		技能施法条件 - 必须在哪些特殊的环境状态下才能施法
		
		返回值为数值类型
		该字段的值来自 skill_db.yml 中的 Requires 节点的 State 字段
		
		可能的返回值:
		----------------
		ST_NONE,					/// 
		ST_HIDDEN,					/// 
		ST_RIDING,					/// 乘骑状态
		ST_FALCON,					/// 猎鹰状态
		ST_CART,					/// 有手推车状态
		ST_SHIELD,					/// 
		ST_RECOVER_WEIGHT_RATE,		/// 
		ST_MOVE_ENABLE,				/// 
		ST_WATER,					/// 站在水面上
		ST_RIDINGDRAGON,			/// 
		ST_WUG,						/// 
		ST_RIDINGWUG,				/// 
		ST_MADO,					/// 魔导机甲状态
		ST_ELEMENTALSPIRIT,			/// 
		ST_ELEMENTALSPIRIT2,		/// 
		ST_PECO,					/// 
		ST_SUNSTANCE,				/// 
		ST_MOONSTANCE,				/// 
		ST_STARSTANCE,				/// 
		ST_UNIVERSESTANCE			/// 
		
	SKI_REQUIRES_STATUS
		技能施法条件 - 必须在哪些特殊的角色状态下才能施法
		
		返回值为数值类型, 返回的是数组长度
		用于承接返回值的数组名称为: @skill_requires_status[]
		若在不关联任何玩家的情况下执行, 则用于承接返回值的数组名称为: $@skill_requires_status[]
		该字段的值来自 skill_db.yml 中的 Requires 节点的 Status 字段
		
		返回值数组中保存是角色状态编号
		备注: StatusChange / 简称 SC / 就是用 sc_start 可以启动的那些状态
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_STATUS,"MO_EXTREMITYFIST");
		dispbottom "MO_EXTREMITYFIST 要求角色有以下编号的状态才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 个状态: 状态编号 %d", .@i, @skill_requires_status[.@i]);
		}
		
	SKI_REQUIRES_SPHERECOST
		技能施法条件 - 必须拥有多少个灵气弹才能施法
		
		返回值为数值类型
		需要在 <技能等级> 字段中传入技能等级
		该字段的值来自 skill_db.yml 中的 Requires 节点的 SphereCost 字段
		
	SKI_REQUIRES_ITEMCOST
		技能施法条件 - 至少持有特定全部物品道具才能施法
		
		返回值为数值类型, 返回的是数组长度
		用于承接返回值的数组共有两个:
			@skill_requires_itemid[]	保存道具编号
			@skill_requires_amount[]	保存所需的道具数量
		若在不关联任何玩家的情况下执行, 则用于承接返回值的两个数组名称为:
			$@skill_requires_itemid[]	保存道具编号
			$@skill_requires_amount[]	保存所需的道具数量
		该字段的值来自 skill_db.yml 中的 Requires 节点的 ItemCost 字段
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_ITEMCOST,"KO_MAKIBISHI");
		dispbottom "KO_MAKIBISHI 要求身上有[以下全部]道具才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 个道具: 物品编号 %d x %d 个", .@i, @skill_requires_itemid[.@i], @skill_requires_amount[.@i]);
		}
		
	SKI_REQUIRES_EQUIPMENT
		技能施法条件 - 至少需要装备任意一件特定道具才能施法
		
		返回值为数值类型, 返回的是数组长度
		用于承接返回值的数组名称为: @skill_requires_equipment[]
		若在不关联任何玩家的情况下执行, 则用于承接返回值的数组名称为: $@skill_requires_equipment[]
		该字段的值来自 skill_db.yml 中的 Requires 节点的 Equipment 字段
		
		返回值数组中保存是装备的道具编号
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_EQUIPMENT,"RL_P_ALTER");
		dispbottom "RL_P_ALTER 要求穿戴[以下任意一件]装备才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 件装备: 物品编号 %d", .@i, @skill_requires_equipment[.@i]);
		}
		
技能编号:
	传入需要查询的技能编号 (定义在 skill_db 中每个技能的 Id 字段)
	例如: 剑士狂击技能的技能编号是 5

技能名称:
	传入需要查询的技能名称 (定义在 skill_db 中每个技能的 Name 字段)
	例如: 剑士狂击技能的名称是 SM_BASH (字符串类型)

技能等级:
	在绝大多数情况下这个参数用来填写要查询的技能等级
	部分查询类型中 <技能等级> 可能会被用作传递其他信息, 例如: SKI_MAXLEVEL_IN_SKILLTREE

返回值:
	根据 <查询的信息类型> 的不同, 返回值的含义会有差异
	具体返回值细节已经在上文中每个不同的 <查询的信息类型> 说明中定义
	
	若传递的 <查询的信息类型>,<技能编号>,<"技能名称"> 无效, 则将报错并返回 -1

--------------------------------------------------------------

*boss_monster "<地图名>",<x坐标>,<y坐标>,"<显示名称>",<魔物编号>,<召唤数量>{,"<死亡事件标签>",<体型大小>,<AI>};
*boss_monster "<地图名>",<x坐标>,<y坐标>,"<显示名称>","<魔物名称>",<召唤数量>{,"<死亡事件标签>",<体型大小>,<AI>};

召唤魔物并使之能被 BOSS 雷达探测 (哪怕被召唤魔物本身不是 BOSS) [人鱼姬的思念]
各参数的详细说明请直接参考 doc/script_commands.txt 中 monster 的说明.

显示名称:
	是指魔物被召唤出来时显示的名字, 可以随便起名.

魔物名称:
	是指魔物在 mob_db 中的 AegisName

提示信息:
	用来记录新创造的魔物游戏单位编号的 $@mobid[] 数组, 在此也有作用.

--------------------------------------------------------------

*sleep3 <休眠毫秒数>;

休眠一段时间再执行后续脚本, 与 sleep2 类似但忽略报错 [人鱼姬的思念]

休眠毫秒数:
	期望脚本休眠多长时间 (单位为毫秒)

返回值:
	该指令无论成功与否, 都不会有返回值

注意事项:
	执行该指令时若脚本没有关联玩家, 则效果等同于 sleep.
	关联玩家情况下若执行该指令后玩家下线, 那么休眠结束后脚本将立刻结束 (不会继续往下执行).

--------------------------------------------------------------

*getquesttime <任务编号>{,<想查询的时间类型>{,<角色编号>}};

查询角色指定任务的时间信息.

任务编号:
	定义在 quest_db.yml 的任务 Id 值

想查询的时间类型:
	0	-	任务的到期时间的 Unix 时间戳 (默认值)
	1	-	任务的开始时间的 Unix 时间戳
	2	-	任务的剩余时间秒数

返回值:
	成功返回时间戳, 失败返回 -1

注意事项:
	任务开始时间会受到 quest_db.yml 中任务时长配置的影响,
	在任务系统中唯一准确的是任务的过期时间,
	任务的开始时间是用过期时间减去 quest_db.yml 中任务时长计算出来的.
	
	任务的剩余时间秒数的最小值为 0, 为 0 可视为任务已过期.

--------------------------------------------------------------

*query_sql_async("您的 SQL 查询语句"{, <用于保存第 1 列的数组变量>{, <用于保存第 2 列的数组变量>{, ...}}});
*query_logsql_async("您的 SQL 查询语句"{, <用于保存第 1 列的数组变量>{, <用于保存第 2 列的数组变量>{, ...}}});

这组脚本指令来自与 rAthena 社区一位名为 inhyositsu 的贡献者.
对应在 rAthena 社区的 Pull Request 地址为: https://github.com/rathena/rathena/pull/5624

以 *_async 结尾的这一组 query 指令将会以异步的方式执行,
这意味着查询过程中将不会阻塞脚本线程 (更重要的是不会阻塞整个地图服务器).

如果您发起一个 SQL 查询而不携带其他用来保存返回值的参数 (例如: Insert 语句),
那么不管 Insert 过程多么耗时脚本都将立刻往下执行, 而不用卡在那里等.

如果你发起了一个类似 SELECT 并且希望获取他返回值数据的请求,
那么脚本将会进入休眠状态 (类似 sleep 指令的效果) 并且等待查询完成后再唤醒脚本继续执行.

注意事项:
	多个 *_async 指令的查询请求是串行的 (异步不等于并行), 他不会卡死地图服务器,
	就用户可能需要等待更长时间才能得到脚本的响应.
	
	例如: 现在您设计了一个复杂的 SQL 查询, 它的查询会耗时 5 秒. 
	那么如果全服 100 个玩家[同时]都去执行这个脚本的话, 这 100 个玩家不会卡死,
	剩下的其他在线玩家也能正常游戏, 
	但服务器内部将需要总共 500 秒来完成这 100 个玩家的查询请求.
	最差最差的情况下, 最后的那个玩家等到脚本被唤醒继续执行, 需要等待 500 秒.
	
使用提示:
	这并不是一个值得提倡使用的指令, 站在游戏体验的角度考虑,
	您依然应该尽可能的不要让玩家有等待的机会.
	这个指令推荐用在一些与玩家无关的定时执行任务, 举个不恰当的例子比如:
	
		每天凌晨 04:00 整时查询 picklog 表看看今天捡取道具最多的玩家是谁,
		把它记下来给个称号: 苏乞儿
	
	之所以称之为不恰当, 是因为你可能有其他性能更优的做法来达成类似的目的.
	
	其次执行的查询要尽量避免锁表, 比如刚刚的需求如果换成:
	
		每天凌晨 04:00 整时将 picklog 表中 7 天以前的记录直接删除掉.
	
	那他就是危险的, 因为在删除 picklog 表的记录时, 数据库会锁定 picklog 表,
	这会导致其他正常需要往这个表插入数据的查询, 被阻塞住.
	
	上面只是举例, 服务端对日志表的写入使用了 INSERT DELAYED 语法,
	可能影响不大 (未考证).
	
三级强悍的注意事项:
	能不用就不用, 用的话要知道自己在什么, 以及可能导致的一些潜在问题.
	我仅代表个人, 主张不应该在地图服务器出于任何目的地执行复杂的、长耗时的 SQL 查询,
	危险程度仅次于焊雷管锯灯泡...

--------------------------------------------------------------

*unitspecialeffect <游戏单位编号>,<特效编号>{,<谁能看见特效>{,<能看见特效的账号编号>}};

使指定游戏单位可以显示某个特效, 类似于 specialeffect 不过它可以控制仅显示给指定范围的玩家目标

游戏单位编号:
	希望给哪个游戏单位显示出特效, 可以是魔物、NPC、生命体、玩家等等
	只需要传递他们的游戏单位编号即可

特效编号:
	游戏特效的 Effect 编号, 可在游戏中使用 @effect 指令来确认特效编号的视觉效果

谁能看见特效:
	用来控制特效的可见范围, 或者说这个单位的特效应该显示给什么范围的玩家

	AREA		-	发送给可视范围内的玩家 (默认)
	SELF		-	发送给自己
					如果指定 <能看见特效的账号编号> 则特效只有指定玩家看到
	PARTY_AREA	- 	发送给以 <游戏单位编号> 为中心可视范围内的队伍成员
	GUILD_AREA	- 	发送给以 <游戏单位编号> 为中心可视范围内的公会成员
	BG_AREA		- 	发送给以 <游戏单位编号> 为中心可视范围内的战场阵营成员

能看见特效的账号编号:
	当 <谁能看见特效> 等于 SELF 的时候
	可以通过此参数指定一个玩家账号编号, 确保只有他才能看到这个特效

返回值:
	该指令无论成功与否, 都不会有返回值

注意事项:
	只有当 <游戏单位编号> 指定的是一个玩家时, <谁能看见特效> 为 PARTY_AREA, 
	GUILD_AREA, BG_AREA 这几个选项才会有效. 否则程序无法判断出应该给什么队伍,
	公会, 战场阵营的成员来发送特效.

--------------------------------------------------------------

*next_dropitem_special <道具绑定类型>,<租赁时长>,<掉落光柱颜色>;

对下一个掉落到地面上的物品进行特殊设置, 支持魔物掉落道具和 makeitem 系列指令

道具绑定类型:
	-1              -   不进行特殊设置
	Bound_None      -   没有绑定 (与 0 等价, 但更推荐用常量)
	Bound_Account   -   绑定账号的道具, 可放个人仓库, 全账号共享
	Bound_Guild     -   绑定公会的道具, 可放公会仓库与他人共享, 拥有物品的人离开公会后物品消失
	Bound_Party     -   绑定队伍的道具, 离开队伍后消失
	Bound_Char      -   绑定角色的道具, 不能放个人仓库

租赁时长:
	从道具掉落时刻起开始计时, 当达到 <租赁时长> 指定的秒数之后道具将从背包被移除
	单位为秒, 若该值非 0 则道具将会被视为租赁道具

掉落光柱颜色:
	物品掉落光柱需要客户端版本大于等于 20180418 才支持, 旧版本客户端没有光柱

	-1                          -   不进行特殊设置
	DROPEFFECT_CLIENT           -   使用客户端的物品光柱配置
	DROPEFFECT_BLUE_PILLAR      -   蓝色光柱
	DROPEFFECT_YELLOW_PILLAR    -   黄色光柱
	DROPEFFECT_PURPLE_PILLAR    -   紫色光柱
	DROPEFFECT_GREEN_PILLAR     -   绿色光柱, 在 20200304 之前会变成橙色光柱
	DROPEFFECT_RED_PILLAR       -   红色光柱

	DROPEFFECT_WHITE_PILLAR     -   白色光柱, 20200304 之后被取消
	DROPEFFECT_ORANGE_PILLAR    -   橙色光柱, 20200304 之后被绿色光柱替换

返回值:
	该指令无论成功与否, 都不会有返回值

注意事项:
	<掉落光环颜色> 的优先级高于 makeitem 系列指令的 <canShowEffect> 字段设置

	若希望对 makeitem / makeitem2 / makeitem3 生效, 那么请在使用这些 makeitem 指令
	之前, 紧挨着使用 next_dropitem_special, 例如:

	next_dropitem_special -1,0,DROPEFFECT_BLUE_PILLAR;
	getmapxy(.@mapname$, .@mapx, .@mapy);
	makeitem 501,1,.@mapname$,.@mapx,.@mapy;

--------------------------------------------------------------

*getgradeitem <物品编号>,<创造数量>,<是否已鉴定>,<精炼值>,<属性>,<第一卡槽>,<第二卡槽>,<第三卡槽>,<第四卡槽>,<装备的附魔评级>,<随机属性的编号数组>,<随机属性的值数组>,<随机属性的参数数组>{,<账号编号>};
*getgradeitem "<物品名称>",<创造数量>,<是否已鉴定>,<精炼值>,<属性>,<第一卡槽>,<第二卡槽>,<第三卡槽>,<第四卡槽>,<装备的附魔评级>,<随机属性的编号数组>,<随机属性的值数组>,<随机属性的参数数组>{,<账号编号>};

创造带有指定附魔评级的道具, 与 getitem4 脚本指令完全等价.

装备的附魔评级:
	ENCHANTGRADE_NONE	表示没有评级
	ENCHANTGRADE_D		表示评级为 D
	ENCHANTGRADE_C		表示评级为 C
	ENCHANTGRADE_B		表示评级为 B
	ENCHANTGRADE_A		表示评级为 A

提示信息:
	从 v1.1.17 开始 rAthena 已经实现了 getitem4 指令,
	因此 getgradeitem 降级为 getitem4 的别名, 为了脚本通用性请尽量使用 getitem4.

--------------------------------------------------------------

*getrateidx <数值型数组变量>;
*getrateidx <数值1>{, <数值2>{, ...<数值n>}};

随机获取一个数值型数组的索引序号,
数组中每个元素的值为权重值, 权重越高命中机率越大.

数值型数组变量:
	存放着权重值的数值型数组变量, 例如下面这个:
	setarray .@rate[0],2,6,3,5;

返回值:
	成功则返回随机命中的索引序号, 失败则报错并中断脚本的执行
	索引序号将从 0 开始计算, 第一个元素为 0, 第二个元素为 1 以此类推...

用法演示:
	setarray .@item[0],501,502,503,504;
	setarray .@rate[0],2,6,3,5;
	getitem .@item[getrateidx(.@rate)],1;
	
	有 2 / (2+6+3+5) = 0.125  * 100 = 12.50% 的机率获得红色药水 (501)
	有 6 / (2+6+3+5) = 0.375  * 100 = 37.50% 的机率获得赤色药水 (502)
	有 3 / (2+6+3+5) = 0.1875 * 100 = 18.75% 的机率获得黄色药水 (503)
	有 5 / (2+6+3+5) = 0.3125 * 100 = 31.25% 的机率获得白色药水 (504)

注意事项:
	数组中若有某个索引的值为 0, 那么该索引将永远不会被命中.

--------------------------------------------------------------

*whodropitem <物品编号/"物品名称">{,<返回的最大记录数>{,<角色编号>}};

查询指定道具会从哪些魔物身上掉落以及掉落的机率信息, 与 @whodrops 管理员指令类似.
查询后将返回按掉率降序排列的结果数组, 结果会与 whodrops 略有差异.

物品编号/"物品名称":
	多类型参数. 可以填写数值类型的道具编号, 或者字符串类型的道具名称.
	推荐使用道具编号, 相较而言结果会更加准确.

返回的最大记录数:
	可选参数, 若不指定此参数则默认返回最多 MAX_SEARCH 条记录 (通常为 5 条记录)
	如果选择填写的话, 可填写的有效区间为 1 - 500 条记录

信息通过变量返回:
	@whodropitem_mob_id[]			魔物编号 - 数值型数组
	@whodropitem_mob_jname$[]		魔物名称 - 字符型数组
									对应 mob_db 魔物数据库中 JapaneseName 字段的值
	@whodropitem_chance[]			掉落被查询道具的机率 - 数值型数组
									有效区间为 0 - 10000, 若为 10000 则表示 100% 掉落
	@whodropitem_count				本次查询返回的记录数 - 数值型变量

返回值:
	返回本次查询返回的记录数, 与 @whodropitem_count 等价

用法演示:
	whodropitem(512, 15);	// 查询掉落 "苹果" 机率最高的前 15 个魔物
	for (.@i = 0; .@i < @whodropitem_count; .@i++) {
		dispbottom(sprintf("第 %02d 条记录 : 编号为 %d 的魔物 [%s] 掉落道具的机率为: %d", .@i + 1, @whodropitem_mob_id[.@i], @whodropitem_mob_jname$[.@i], @whodropitem_chance[.@i]));
	}

注意事项:
	返回值数组变量是 @ 开头的角色变量.
	若指令在不关联任何玩家的情况下被执行之后, 可以改用 $@ 变量来承接返回值.
	
	若您使用 $@ 变量来承接返回值内容的话,
	调用 whodropitem 之后应该立刻使用变量的内容, 因为 $@ 变量是全服共享的, 
	如果调用完成后不立刻使用, 可能里面填充的内容就被其他玩家调用 whodropitem 替换掉了.
	
	如果您希望列出一些菜单项让玩家做选择的话, 请使用 @ 变量承接.
	因为 @ 变量只保存在玩家角色身上, 不会被服务器其他玩家调用 whodropitem 指令而覆盖.
	
	与 getinventorylist 指令一样, 请避免使用 getarraysize 来计算返回数组的长度,
	而是使用 @whodropitem_count 来作为返回数组中有效内容的最大数量, 否则可能会读取到部分垃圾数据.
	
	返回的掉率将会参考等级惩罚、VIP 会员加成等结果;
	若希望排除这部分影响, 可以在不关联玩家的情况下执行该指令.

--------------------------------------------------------------

*getbossinfo {<"地图名称">{,<魔物编号>{,<角色编号>}}};

查询 BOSS 魔物重生时间及其坟墓等信息

地图名称:
	指定的地图名称, 比如 "prontera" 表示普隆德拉
	地图名称可以设置为 "this", 表示获取当前脚本关联玩家所在的地图
	地图名称可以设置为 "all", 表示获取全服地图

魔物编号:
	查询特定魔物编号的 BOSS 魔物信息

角色编号:
	若指定了角色编号则使用 "this" 地图名称时将会查询指定角色所在地图的魔物刷新点信息
	此外 @ 变量的值也将绑定记录到该角色身上

返回值:
	返回查询到的记录数, 查询失败或查无记录则返回 0

信息通过变量返回:
	@boss_mapid[]				BOSS 魔物所在的地图编号 (通常没啥作用) - 数值型数组
	@boss_mapname$[]			BOSS 魔物所在的地图名称 - 字符型数组
	@boss_x[]					BOSS 魔物所在的 x 坐标 - 数值型数组
	@boss_y[]					BOSS 魔物所在的 y 坐标 - 数值型数组
		
	@boss_gid[]					BOSS 魔物的游戏单位编号 - 数值型数组
								注意: 在熊猫模拟器中, 魔物重生时候的游戏单位编号可能会变化
	@boss_spawn[]				BOSS 魔物将在多少毫秒之后刷新复活 - 数值型数组
								若为 0 则表示现在目标存活
	@boss_classid[]				BOSS 魔物的魔物编号 - 数值型数组
		
	@boss_tomb_mapid[]			BOSS 墓碑所在的地图编号 (通常没啥作用) - 数值型数组
	@boss_tomb_mapname$[]   	BOSS 墓碑所在的地图名称 - 字符型数组
	@boss_tomb_x[]          	BOSS 墓碑所在的 x 坐标 - 数值型数组
	@boss_tomb_y[]          	BOSS 墓碑所在的 y 坐标 - 数值型数组
	
	@boss_tomb_gid[]			BOSS 墓碑的游戏单位编号 - 数值型数组
								若为 0 则表示还没生成坟墓
	@boss_tomb_createtime[]		BOSS 墓碑的创建时间 (Unix 时间戳) - 数值型数组
	
	@boss_tomb_respawnsecs[]	BOSS 魔物将在多少秒之后刷新复活 - 数值型数组
	@boss_tomb_respawntime[]	BOSS 魔物的复活时间 (Unix 时间戳, 读取不到则为 -1)
	
	@boss_tomb_killer_name$[]	击杀 BOSS 魔物的玩家名称 - 字符型数组
	@boss_tomb_killer_gid[]		击杀 BOSS 魔物的玩家游戏单位编号 - 数值型数组
	
	@boss_count					本次查询返回的记录数 - 数值型变量

举例说明:
	getbossinfo();				// 查询全服地图的 BOSS 魔物信息
	getbossinfo("this");		// 查询玩家当前地图的 BOSS 魔物信息
	getbossinfo("all", 1039);	// 查询全服地图中魔物编号为 1039 的 BOSS 魔物信息
	getbossinfo("gef_dun01");	// 查询 gef_dun01 地图上的 BOSS 魔物信息
	
注意事项:
	返回值数组变量是 @ 开头的角色变量.
	若指令在不关联任何玩家的情况下被执行之后, 可以改用 $@ 变量来承接返回值.
	
	若您使用 $@ 变量来承接返回值内容的话,
	调用 getbossinfo 之后应该立刻使用变量的内容, 因为 $@ 变量是全服共享的, 
	如果调用完成后不立刻使用, 可能里面填充的内容就被其他玩家调用 getbossinfo 替换掉了.
	
	当使用 "this" 指令的时候, 若脚本不关联任何玩家的话, 那么必须指定 <角色编号>,
	否则地图服务器将无法理解 "this" 具体是哪一张地图.
	
	如果您希望列出一些菜单项让玩家做选择的话, 请使用 @ 变量承接.
	因为 @ 变量只保存在玩家角色身上, 不会被服务器其他玩家调用 getbossinfo 指令而覆盖.
	
	与 getinventorylist 指令一样, 请避免使用 getarraysize 来计算返回数组的长度,
	而是使用 @boss_count 来作为返回数组中有效内容的最大数量, 否则可能会读取到部分垃圾数据.
	
	若想在地图服务器启动就能获取所有 BOSS 魔物信息,
	请将 conf/battle/monster.conf 的 dynamic_mobs 设置为 no,
	否则由于动态生成魔物的影响, 必须在 BOSS 所在地图有玩家前往一次之后,
	才能看到查询到那张地图的 BOSS 魔物信息.

--------------------------------------------------------------

*setmapflag "<地图名称>",<地图标记常量>{,<参数1>{,<参数2>{,<参数3>{,<参数4>}}}};

该指令在 rAthena 的基础上拓展了更多的参数.
当你计划使用 setmapflag 对熊猫拓展的地图标记 (doc/pandas_mapflags.txt) 进行设置时,
若拓展的地图标记需要一个或多个参数, 可以按照上面的格式进行顺序书写.

使用例子:
	// 为 prontera 设置 noattack2 标记, 禁止"生命体和魔物"使用普通攻击.
	// 已知生命体标记位值为 8, 魔物标记位值为 2,
	// 想同时禁止他们我们需要传递 8 + 2 = 10 作为这个地图标记的第一个参数.
	
	setmapflag("prontera",mf_noattack2,10);
	
	// 如果未来有某个地图标记需要支持 4 个参数, 例如参数的值分别是 5,6,7,8 的话
	// 直接按顺序书写就行, 例如:
	
	setmapflag("prontera",mf_something,5,6,7,8);

--------------------------------------------------------------
